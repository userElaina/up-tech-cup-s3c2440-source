<HTML><HEAD><TITLE>basic_string</TITLE></HEAD><BODY BGCOLOR=#FFFFFF>
<IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0><BR>
<A HREF="bas_0582.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="bas_3672.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><BR>

<H2>basic_string</H2>
<PRE><HR>Strings Library
<HR></PRE>
<UL>
<LI><A HREF="#Summary">Summary</A></LI>
<LI><A HREF="#memindex">Data Type and Member Function Indexes</A></LI>
<LI><A HREF="#Synopsis">Synopsis</A></LI>
<LI><A HREF="#Description">Description</A></LI>
<LI><A HREF="#Interface">Interface</A></LI>
<LI><A HREF="#Constructors">Constructors</A></LI>
<LI><A HREF="#Destructors">Destructors</A></LI>
<LI><A HREF="#Operators">Operators</A></LI>
<LI><A HREF="#Iterators">Iterators</A></LI>
<LI><A HREF="#Allocator">Allocator</A></LI>
<LI><A HREF="#Member Functions">Member Functions</A></LI>
<LI><A HREF="#Non-member Operators">Non-member Operators</A></LI>
<LI><A HREF="#Non-member Functions">Non-member Functions</A></LI>
<LI><A HREF="#Example">Example</A></LI>
<LI><A HREF="#See Also">See Also</A></LI>

</UL>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A templatized class for handling sequences of character-like entities. <B><I><A HREF="str_8586.htm">string</A></I></B> and <B><I>wstring</I></B> are specialized versions of <B><I>basic_string</I></B> for <SAMP>char</SAMP>'s and <SAMP>wchar_t</SAMP>'s, respectively.</P>
<UL>
<PRE>typedef basic_string &lt;char&gt; string;
typedef basic_string &lt;wchar_t&gt; wstring;</PRE>
</UL>

<A NAME="memindex"><H3>Data Type and Member Function Indexes<BR>(exclusive of constructors and destructors)</H3></A>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Member Functions</B></TD></TR><TR><TD VALIGN=top><A HREF="#Member Functionsappend()">append()</A><BR>
 <A HREF="#Member Functionsassign()">assign()</A><BR>
 <A HREF="#Member Functionsat()">at()</A><BR>
 <A HREF="#Iteratorsbegin()">begin()</A><BR>
 <A HREF="#Member Functionscapacity()">capacity()</A><BR>
 <A HREF="#Member Functionscompare()">compare()</A><BR>
 <A HREF="#Member Functionscopy()">copy()</A><BR>
 <A HREF="#Member Functionsc_str()">c_str()</A><BR>
 <A HREF="#Member Functionsdata()">data()</A><BR>
 <A HREF="#Member Functionsempty()">empty()</A><BR>
 <A HREF="#Iteratorsend()">end()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Functionserase()">erase()</A><BR>
 <A HREF="#Member Functionsfind()">find()</A><BR>
 <A HREF="#Member Functionsfind_first_not_of()">find_first_not_of()</A><BR>
 <A HREF="#Member Functionsfind_first_of()">find_first_of()</A><BR>
 <A HREF="#Member Functionsfind_last_not_of()">find_last_not_of()</A><BR>
 <A HREF="#Member Functionsfind_last_of()">find_last_of()</A><BR>
 <A HREF="#Non-member Functionsgetline()">getline()</A><BR>
 <A HREF="#Allocatorget_allocator()">get_allocator()</A><BR>
 <A HREF="#Member Functionsinsert()">insert()</A><BR>
 <A HREF="#Member Functionslength()">length()</A><BR>
 <A HREF="#Member Functionsmax_size()">max_size()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Non-member Operatorsoperator!=()">operator!=()</A><BR>
 <A HREF="#Non-member Operatorsoperator&gt;&gt;()">operator&gt;&gt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&gt;()">operator&gt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&gt;=()">operator&gt;=()</A><BR>
 <A HREF="#Non-member Operatorsoperator&lt;&lt;()">operator&lt;&lt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&lt;()">operator&lt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&lt;=()">operator&lt;=()</A><BR>
 <A HREF="#Non-member Operatorsoperator+()">operator+()</A><BR>
 <A HREF="#Operatorsoperator+=()">operator+=()</A><BR>
 <A HREF="#Operatorsoperator=()">operator=()</A><BR>
 <A HREF="#Non-member Operatorsoperator==()">operator==()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Operatorsoperator[]()">operator[]()</A><BR>
 <A HREF="#Iteratorsrbegin()">rbegin()</A><BR>
 <A HREF="#Iteratorsrend()">rend()</A><BR>
 <A HREF="#Member Functionsreplace()">replace()</A><BR>
 <A HREF="#Member Functionsreserve()">reserve()</A><BR>
 <A HREF="#Member Functionsresize()">resize()</A><BR>
 <A HREF="#Member Functionsrfind()">rfind()</A><BR>
 <A HREF="#Member Functionssize()">size()</A><BR>
 <A HREF="#Member Functionssubstr()">substr()</A><BR>
 <A HREF="#Member Functionsswap()">swap()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>
<PRE>#include &lt;string&gt;

template &lt;class charT,
          class traits = char_traits&lt;charT&gt;,
          class Allocator = allocator&lt;charT&gt; &gt;

class basic_string;</PRE>

</PRE>

<A NAME="Description"><H3>Description</H3></A>
<P><B><I>basic_string&lt;charT, traits, Allocator&gt;</I></B> is a homogeneous collection of character-like entities that includes string functions such as compare, append, assign, insert, remove, and replace, along with various searches. <B><I>basic_string</I></B> also functions as an STL sequence container that provides random access iterators. This allows some of the generic algorithms to apply to strings.</P>
<P>Any underlying character-like type may be used as long as an appropriate <SAMP>char_traits</SAMP> class is included or the default <SAMP>traits</SAMP> class is applicable. </P>

<A NAME="Interface"><H3>Interface</H3></A>
<UL>
<PRE>template &lt;class charT,
          class traits = char_traits&lt;charT&gt;,
          class Allocator = allocator&lt;charT&gt; &gt;
class basic_string {

public:

// Types

typedef traits                               traits_type;
typedef typename traits::char_type           value_type;
typedef Allocator                            allocator_type;
typedef typename Allocator::size_type        size_type;
typedef typename Allocator::difference_type difference_type;
typedef typename Allocator::reference        reference;
typedef typename Allocator::const_reference const_reference;
typedef typename Allocator::pointer          pointer;
typedef typename Allocator::const_pointer    const_pointer;
typedef typename Allocator::pointer          iterator;
typedef typename Allocator::const_pointer    const_iterator;
typedef std::reverse_iterator&lt;const_iterator&gt;
                                     const_reverse_iterator;
typedef std::reverse_iterator&lt;iterator&gt;      reverse_iterator;

static const size_type npos = -1;

// Constructors/Destructors

explicit basic_string(const Allocator&amp; = Allocator());
basic_string (const basic_string&lt;charT, traits,
              Allocator&gt;&amp;);
basic_string(const basic_string&amp;, size_type, 
             size_type = npos, 
             const Allocator&amp; a = Allocator());
basic_string(const charT*, size_type,
             const Allocator&amp; = Allocator());
basic_string(const charT*, const Allocator&amp; = Allocator());
basic_string(size_type, charT,
             const Allocator&amp; = Allocator());
template &lt;class InputIterator&gt;
basic_string(InputIterator, InputIterator,
             const Allocator&amp; = Allocator());
~basic_string();

// Assignment operators
 basic_string&amp; operator=(const basic_string&amp;);
 basic_string&amp; operator=(const charT*);
 basic_string&amp; operator=(charT);

// Iterators

 iterator       begin();
 const_iterator begin() const;
 iterator       end();
 const_iterator end() const;

 reverse_iterator       rbegin();
 const_reverse_iterator rbegin() const;
 reverse_iterator       rend();
 const_reverse_iterator rend() const;

// Capacity

   size_type       size() const;
   size_type       length() const;
   size_type       max_size() const;
   void            resize(size_type, charT);
   void            resize(size_type);
   size_type       capacity() const;
   void            reserve(size_type = 0);
   bool            empty() const;

// Element access

   const_reference operator[](size_type) const;
   reference       operator[](size_type);
   const_reference at(size_type) const;
   reference       at(size_type);

// Modifiers

   basic_string&amp; operator+=(const basic_string&amp;);
   basic_string&amp; operator+=(const charT*);
   basic_string&amp; operator+=(charT);
   
   basic_string&amp; append(const basic_string&amp;);
   basic_string&amp; append(const basic_string&amp;,
                        size_type, size_type);
   basic_string&amp; append(const charT*, size_type);
   basic_string&amp; append(const charT*);
   basic_string&amp; append(size_type, charT);
   template&lt;class InputIterator&gt;
    basic_string&amp; append(InputIterator, InputIterator);
   
   basic_string&amp; assign(const basic_string&amp;);
   basic_string&amp; assign(const basic_string&amp;,
                        size_type, size_type);
   basic_string&amp; assign(const charT*, size_type);
   basic_string&amp; assign(const charT*);
   basic_string&amp; assign(size_type, charT);
   template&lt;class InputIterator&gt;
    basic_string&amp; assign(InputIterator, InputIterator);
   
   basic_string&amp; insert(size_type, const basic_string&amp;);
   basic_string&amp; insert(size_type, const basic_string&amp;,
                        size_type, size_type);
   basic_string&amp; insert(size_type, const charT*, size_type);
   basic_string&amp; insert(size_type, const charT*);
   basic_string&amp; insert(size_type, size_type, charT);
   iterator insert(iterator, charT = charT());
   void insert(iterator, size_type, charT);
   template&lt;class InputIterator&gt;
    void insert(iterator, InputIterator, InputIterator);

   basic_string&amp; erase(size_type = 0, size_type= npos);
   iterator erase(iterator);
   iterator erase(iterator, iterator);

   basic_string&amp; replace(size_type, size_type,
                         const basic_string&amp;);
   basic_string&amp; replace(size_type, size_type,
                         const basic_string&amp;,
                         size_type, size_type);
   basic_string&amp; replace(size_type, size_type,
                         const charT*, size_type);
   basic_string&amp; replace(size_type, size_type,
                         const charT*);
   basic_string&amp; replace(size_type, size_type,
                         size_type, charT);
   basic_string&amp; replace(iterator, iterator,
                         const basic_string&amp;);
   basic_string&amp; replace(iterator, iterator,
                         const charT*, size_type);
   basic_string&amp; replace(iterator, iterator,
                         const charT*);
   basic_string&amp; replace(iterator, iterator,
                         size_type, charT);
   template&lt;class InputIterator&gt;
    basic_string&amp; replace(iterator, iterator,
                         InputIterator, InputIterator);

   size_type copy(charT*, size_type, size_type = 0) const;
   void swap(basic_string&lt;charT, traits, Allocator&gt;&amp;);

// String operations

   const charT* c_str() const;
   const charT* data() const;
   const allocator_type&amp; get_allocator() const;
   
   size_type find(const basic_string&amp;,
                  size_type = 0) const;
   size_type find(const charT*,
                  size_type, size_type) const;
   size_type find(const charT*, size_type = 0) const;
   size_type find(charT, size_type = 0) const;
   size_type rfind(const basic_string&amp;,
                   size_type = npos) const;
   size_type rfind(const charT*,
                   size_type, size_type) const;
   size_type rfind(const charT*,
                   size_type = npos) const;
   size_type rfind(charT, size_type = npos) const;

   size_type find_first_of(const basic_string&amp;,
                           size_type = 0) const;
   size_type find_first_of(const charT*,
                           size_type, size_type) const;
   size_type find_first_of(const charT*,
                           size_type = 0) const;
   size_type find_first_of(charT, size_type = 0) const;

   size_type find_last_of(const basic_string&amp;,
                          size_type = npos) const;
   size_type find_last_of(const charT*,
                          size_type, size_type) const;
   size_type find_last_of(const charT*, size_type = npos)
                        const;
   size_type find_last_of(charT, size_type = npos) const;

   size_type find_first_not_of(const basic_string&amp;,
                               size_type = 0) const;
   size_type find_first_not_of(const charT*,
                               size_type, size_type) const;
   size_type find_first_not_of(const charT*, size_type = 0)
                           const;
   size_type find_first_not_of(charT, size_type = 0) const;

   size_type find_last_not_of(const basic_string&amp;,
                              size_type = npos) const;
   size_type find_last_not_of(const charT*,
                              size_type, size_type) const;
   size_type find_last_not_of(const charT*, 
                              size_type = npos) const;
   size_type find_last_not_of(charT, size_type = npos)
                             const;

   basic_string substr(size_type = 0, size_type = npos)
                      const;
   int compare(const basic_string&amp;) const;
   int compare(size_type, size_type, const basic_string&amp;)
              const;
   int compare(size_type, size_type, const basic_string&amp;,
               size_type, size_type) const;
   int compare(size_type, size_type, charT*) const;
   int compare(charT*) const;
   int compare(size_type, size_type, const charT*,
               size_type) const;
};

// Non-member Operators

template &lt;class charT, class traits, class Allocator&gt;
 basic_string operator+ (const basic_string&amp;,
                         const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 basic_string operator+ (const charT*, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 basic_string operator+ (charT, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 basic_string operator+ (const basic_string&amp;, const charT*);
template &lt;class charT, class traits, class Allocator&gt;
 basic_string operator+ (const basic_string&amp;, charT);

template &lt;class charT, class traits, class Allocator&gt;
 bool operator== (const basic_string&amp;, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator== (const charT*, const basic_string&amp;);
template &lt;class charT, class traits , class Allocator&gt;
 bool operator== (const basic_string&amp;, const charT*);

template &lt;class charT, class traits, class Allocator&gt;
 bool operator&lt; (const basic_string&amp;, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator&lt; (const charT*, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator&lt; (const basic_string&amp;, const charT*);

template &lt;class charT, class traits, class Allocator&gt;
 bool operator!= (const basic_string&amp;, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator!= (const charT*, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator!= (const basic_string&amp;, const charT*);

template &lt;class charT, class traits, class Allocator&gt;
 bool operator&gt; (const basic_string&amp;, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator&gt; (const charT*, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator&gt; (const basic_string&amp;, const charT*);

template &lt;class charT, class traits, class Allocator&gt;
 bool operator&lt;= (const basic_string&amp;, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator&lt;= (const charT*, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator&lt;= (const basic_string&amp;, const charT*);


template &lt;class charT, class traits, class Allocator&gt;
 bool operator&gt;= (const basic_string&amp;, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator&gt;= (const charT*, const basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 bool operator&gt;= (const basic_string&amp;, const charT*);

template &lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; a, 
          basic_string&lt;charT,traits,Allocator&gt;&amp; b);

template&lt;class charT, class traits, class Allocator&gt;
 basic_istream&lt;charT, traits&gt;&amp; operator&gt;&gt; 
                            (istream&amp;, basic_string&amp;);
template &lt;class charT, class traits, class Allocator&gt;
 basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt; 
                            (ostream&amp;, const basic_string&amp;);
template &lt;class Stream, class charT, 
          class traits, class Allocator&gt;
 basic_istream&lt;charT, traits&gt;&amp; getline 
                            (Stream&amp;, basic_string&amp;, charT);</PRE>

</UL>

<A NAME="Constructors"><H3>Constructors</H3></A>
<P>In all cases, the <SAMP>Allocator</SAMP> parameter is used for storage management.</P>


<PRE>explicit 
<B>basic_string</B> (const Allocator&amp; a = Allocator());</PRE>

<UL>
<P>The default constructor. Creates a <B><I>basic_string</I></B> with the following effects:</P>
</UL>

<UL><TABLE>
<TR><TD VALIGN=top><SAMP>data()  </TD>
<TD></SAMP>a non-null pointer that is copyable and can have <SAMP>0</SAMP> added to it</TD></TR>

<TR><TD VALIGN=top><SAMP>size()  </TD>
<TD>0</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>capacity()  </TD>
<TD></SAMP>an unspecified value</TD></TR>
</TABLE></UL>


<PRE><B>basic_string</B> (const basic_string&lt;T, traits, 
               Allocator&gt;&amp; str);</PRE>

<UL>
<P>Creates a string that is a copy of <SAMP>str</SAMP>.</P>
</UL>



<PRE><B>basic_string</B> (const basic_string&amp; str, size_type pos,
              size_type n= npos, const allocator&amp;
              a=allocator());</PRE>

<UL>
<P>Creates a string of <SAMP>pos&lt;=size()</SAMP> and determines length <SAMP>rlen</SAMP> of the initial string value as the smaller of <SAMP>n</SAMP> and <SAMP>str.size() - pos</SAMP>. This has the following effects:</P>
</UL>

<UL><TABLE>
<TR><TD VALIGN=top><SAMP>data()  </TD>
<TD></SAMP>points to the first element of an allocated copy of <SAMP>rlen</SAMP> elements of the string controlled by <SAMP>str</SAMP> beginning at position <SAMP>pos</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>size()  </TD>
<TD>rlen</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>capacity()  </TD>
<TD></SAMP>a value at least as large as <SAMP>size()</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>get_allocator()  </TD>
<TD>str.get_allocator()</SAMP></TD></TR>
</TABLE></UL>

<UL>
<P>An <SAMP>out_of_range</SAMP> exception is thrown if <SAMP>pos&gt;str.size()</SAMP>.</P>
</UL>



<PRE><B>basic_string</B> (const charT* s, size_type n,
              const Allocator&amp; a = Allocator());</PRE>

<UL>
<P>Creates a string that contains the first <SAMP>n</SAMP> characters of <SAMP>s</SAMP>. <SAMP>s</SAMP> must not be a <SAMP>NULL</SAMP> pointer. The effects of this constructor are:</P>
</UL>

<UL><TABLE>
<TR><TD VALIGN=top><SAMP>data()  </TD>
<TD></SAMP>points to the first element of an allocated copy of the array whose first element is pointed to by <SAMP>s</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>size()  </TD>
<TD>n</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>capacity()  </TD>
<TD></SAMP>a value at least as large as <SAMP>size()</SAMP></TD></TR>
</TABLE></UL>
<UL>
<P>A <SAMP>length_error</SAMP> exception is thrown if <SAMP>n == npos.</SAMP></P>
</UL>



<PRE><B>basic_string</B> (const charT * s, 
              const Allocator&amp; a = Allocator());</PRE>

<UL>
<P>Constructs a string containing all characters in <SAMP>s</SAMP> up to, but not including, a <SAMP>traits::eos()</SAMP> character. <SAMP>s</SAMP> must not be a null pointer. The effects of this constructor are:</P>
</UL>

<UL><TABLE>
<TR><TD VALIGN=top><SAMP>data()  </TD>
<TD></SAMP>points to the first element of an allocated copy of the array whose first element is pointed to by <SAMP>s</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>size()  </TD>
<TD>traits::length(s)</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>capacity()  </TD>
<TD></SAMP>a value at least as large as <SAMP>size()</SAMP></TD></TR>
</TABLE></UL>


<PRE><B>basic_string</B> (size_type n, charT c, 
              const Allocator&amp; a = Allocator());</PRE>

<UL>
<P>Constructs a string containing <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>. A <SAMP>length_error</SAMP> exception is thrown if <SAMP>n == npos</SAMP>. The effects of this constructor are:</P>
</UL>

<UL><TABLE>
<TR><TD VALIGN=top><SAMP>data()  </TD>
<TD></SAMP>points to the first element of an allocated array of <SAMP>n</SAMP> elements, each storing the initial value <SAMP>c</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>size()  </TD>
<TD>n</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>capacity()  </TD>
<TD></SAMP>a value at least as large as <SAMP>size()</SAMP></TD></TR>
</TABLE></UL>


<PRE>template &lt;class InputIterator&gt;
<B>basic_string</B> (InputIterator first, InputIterator last,
               const Allocator&amp; a = Allocator());</PRE>

<UL>
<P>Creates a <B><I>basic_string</I></B> of length <SAMP>last - first</SAMP> filled with all values obtained by dereferencing the <SAMP>InputIterators</SAMP> on the range <SAMP>[first, last)</SAMP>. The effects of this constructor are:</P>
</UL>

<UL><TABLE>
<TR><TD VALIGN=top><SAMP>data()  </TD>
<TD></SAMP>points to the first element of an allocated copy of the elements in the range <SAMP>[first,last)</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>size()  </TD>
<TD></SAMP>distance between <SAMP>first</SAMP> and <SAMP>last</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>capacity()  </TD>
<TD></SAMP>a value at least as large as <SAMP>size()</SAMP></TD></TR>
</TABLE></UL>

<A NAME="Destructors"><H3>Destructors</H3></A>


<PRE><B>~basic_string</B> ();</PRE>

<UL>
<P>Releases any allocated memory for this <B><I>basic_string</I></B>.</P>
</UL>


<A NAME="Operators"><H3>Operators</H3></A>


<A NAME="Operatorsoperator=()"></A><PRE>basic_string&amp;
<B>operator=</B> (const basic_string&amp; str);</PRE>

<UL>
<P>Sets the contents of this string to be the same as <SAMP>str</SAMP>. The effects of <SAMP>operator=</SAMP> are:</P>
</UL>

<UL><TABLE>
<TR><TD VALIGN=top><SAMP>data()  </TD>
<TD></SAMP>points to the first element of an allocated copy of the array whose first element is pointed to by <SAMP>str.size()</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>size()  </TD>
<TD>str.size()</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>capacity()  </TD>
<TD></SAMP>a value at least as large as <SAMP>size()</SAMP></TD></TR>
</TABLE></UL>


<PRE>basic_string&amp; 
<B>operator=</B> (const charT * s);</PRE>

<UL>
<P>Sets the contents of this string to be the same as <SAMP>s</SAMP> up to, but not including, the <SAMP>traits::eos()</SAMP> character.</P>
</UL>



<PRE>basic_string&amp; 
<B>operator=</B> (charT c);</PRE>

<UL>
<P>Sets the contents of this string to be equal to the single <SAMP>charT</SAMP> <SAMP>c</SAMP>.</P>
</UL>



<A NAME="Operatorsoperator[]()"></A><PRE>const_reference 
<B>operator[]</B> (size_type pos) const;
reference 
<B>operator[]</B> (size_type pos);</PRE>

<UL>
<P>If <SAMP>pos &lt; size()</SAMP>, returns the element at position <SAMP>pos</SAMP> in this string. If <SAMP>pos == size()</SAMP>, the <SAMP>const</SAMP> version returns <SAMP>charT()</SAMP>, the behavior of the non-<SAMP>const</SAMP> version is undefined. The reference returned by either version is invalidated by any call to <SAMP>c_str()</SAMP>, <SAMP>data()</SAMP>, or any non-<SAMP>const</SAMP> member function for the object.</P>
</UL>



<A NAME="Operatorsoperator+=()"></A><PRE>basic_string&amp; 
<B>operator+=</B> (const basic_string&amp; s);
basic_string&amp; 
<B>operator+=</B> (const charT* s);
basic_string&amp; 
<B>operator+=</B> (charT c);</PRE>

<UL>
<P>Concatenates a string onto the current contents of this string. The second member operator uses <SAMP>traits::length()</SAMP> to determine the number of elements from <SAMP>s</SAMP> to add. The third member operator adds the single character <SAMP>c</SAMP>. All return a reference to this string after completion.</P>
</UL>


<A NAME="Iterators"><H3>Iterators</H3></A>


<A NAME="Iteratorsbegin()"></A><PRE>iterator <B>begin</B> ();
const_iterator <B>begin</B> () const;</PRE>

<UL>
<P>Returns an iterator initialized to the first element of the string.</P>
</UL>



<A NAME="Iteratorsend()"></A><PRE>iterator <B>end</B> ();
const_iterator <B>end</B> () const;</PRE>

<UL>
<P>Returns an iterator initialized to the position after the last element of the string.</P>
</UL>



<A NAME="Iteratorsrbegin()"></A><PRE>reverse_iterator <B>rbegin</B> ();
const_reverse_iterator <B>rbegin</B> () const;</PRE>

<UL>
<P>Returns an iterator equivalent to <SAMP>reverse_iterator(end())</SAMP>.</P>
</UL>



<A NAME="Iteratorsrend()"></A><PRE>reverse_iterator <B>rend</B> ();
const_reverse_iterator <B>rend</B> () const;</PRE>

<UL>
<P>Returns an iterator equivalent to <SAMP>reverse_iterator(begin())</SAMP>.</P>
</UL>


<A NAME="Allocator"><H3>Allocator</H3></A>


<A NAME="Allocatorget_allocator()"></A><PRE>const allocator_type <B>get_allocator</B> () const;</PRE>

<UL>
<P>Returns a copy of the allocator used by self for storage management.</P>
</UL>


<A NAME="Member Functions"><H3>Member Functions</H3></A>


<A NAME="Member Functionsappend()"></A><PRE>basic_string&amp; 
<B>append</B> (const basic_string&amp; s, size_type pos, 
        size_type npos);
basic_string&amp;
<B>append</B> (const basic_string&amp; s);
basic_string&amp; 
<B>append</B> (const charT* s, size_type n);
basic_string&amp; 
<B>append</B> (const charT* s);
basic_string&amp; 
<B>append</B> (size_type n, charT c );
template&lt;class InputIterator&gt;
basic_string&amp; 
<B>append</B> (InputIterator first, InputIterator last);</PRE>

<UL>
<P>Append another string to the end of this string. The first two functions append the lesser of <SAMP>n</SAMP> and <SAMP>s.size() - pos</SAMP> characters of <SAMP>s</SAMP>, beginning at position <SAMP>pos</SAMP> to this string.   The second member throws an <SAMP>out_of_range</SAMP> exception if <SAMP>pos &gt; str.size()</SAMP>. The third member appends <SAMP>n</SAMP> characters of the array pointed to by <SAMP>s</SAMP>. The fourth variation appends elements from the array pointed to by <SAMP>s</SAMP> up to, but not including, a <SAMP>charT()</SAMP> character. The fifth variation appends <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>. The final <SAMP>append</SAMP> function appends the elements specified in the range <SAMP>[first, last)</SAMP>. </P>
<P>All functions throw a <SAMP>length_error</SAMP> exception if the resulting lengths exceed <SAMP>max_size()</SAMP>. All return a reference to this string after completion.</P>
</UL>



<A NAME="Member Functionsassign()"></A><PRE>basic_string&amp;
<B>assign</B> (const basic_string&amp; s);
basic_string&amp; 
<B>assign</B> (const basic_string&amp; s,
        size_type pos, size_type n);
basic_string&amp; 
<B>assign</B> (const charT* s, size_type n);
basic_string&amp;
<B>assign</B> (const charT* s);
basic_string&amp;
<B>assign</B> (size_type n, charT c );
template&lt;class InputIterator&gt;
basic_string&amp; 
<B>assign</B> (InputIterator first, InputIterator last);</PRE>

<UL>
<P>Replace the value of this string with the value of another.   </P>
<P>All versions of the function assign values to this string. The first two variations assign the lesser of <SAMP>n</SAMP> and <SAMP>s.size() - pos</SAMP> characters of <SAMP>s</SAMP>, beginning at position <SAMP>pos</SAMP>. The second variation throws an <SAMP>out_of_range</SAMP> exception if <SAMP>pos &gt; str.size()</SAMP>. The third version of the function assigns <SAMP>n</SAMP> characters of the array pointed to by <SAMP>s</SAMP>. The fourth version assigns elements from the array pointed to by <SAMP>s</SAMP> up to, but not including, a <SAMP>charT()</SAMP> character. The fifth assigns one or <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>. The last variation assigns the members specified by the range <SAMP>[first, last)</SAMP>. </P>
<P>All functions throw a <SAMP>length_error</SAMP> exception if the resulting lengths exceed <SAMP>max_size()</SAMP>. All return a reference to this string after completion.</P>
</UL>



<A NAME="Member Functionsat()"></A><PRE>const_reference 
<B>at</B> (size_type pos) const;
reference 
<B>at</B> (size_type pos);</PRE>

<UL>
<P>If <SAMP>pos &lt; size()</SAMP>, returns the element at position <SAMP>pos</SAMP> in this string. Otherwise, an <SAMP>out_of_range</SAMP> exception is thrown.</P>
</UL>



<A NAME="Member Functionscapacity()"></A><PRE>size_type 
<B>capacity</B> () const;</PRE>

<UL>
<P>Returns the current storage capacity of the string. This is guaranteed to be at least as large as <SAMP>size()</SAMP>.</P>
</UL>



<A NAME="Member Functionscompare()"></A><PRE>int 
<B>compare</B> (const basic_string&amp; str);</PRE>

<UL>
<P>Returns the result of a lexicographical comparison between elements of this string and elements of <SAMP>str</SAMP>. The return value is: </P>
</UL>

<UL><TABLE>
<TR><TD VALIGN=top><SAMP>&lt;0  </TD>
<TD>if size() &lt; str.size()</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>0  </TD>
<TD>if size() == str.size()</SAMP></TD></TR>

<TR><TD VALIGN=top><SAMP>&gt;0  </TD>
<TD>if size() &gt; str.size()</SAMP></TD></TR>
</TABLE></UL>


<PRE>int
<B>compare</B> (size_type pos1, size_type n1, 
         const basic_string&amp; str) const;
int
<B>compare</B> (size_type pos1, size_type n1, 
         const basic_string&amp; str,
         size_type pos2, size_type n2) const;
int 
<B>compare</B> (charT* s) const;
int
<B>compare</B> (size_type pos, size_type n1, charT* s) const;
int
<B>compare</B> (size_type pos, size_type n1, charT* s, 
         size_type n2) const;</PRE>

<UL>
<P>Returns the result of a lexicographical comparison between elements of this string and a given comparison string. The members return, respectively:</P>
<UL>
<PRE>basic_string(*this,pos1,n1).compare (str)
basic_string(*this,pos1,n1).compare (basic_string 
                                     (str, pos2, n2))
*this.compare (basic_string(s))
basic_string(*this,pos,n1).compare (basic_string
                                    (s, npos))
basic_string(*this,pos,n1).compare (basic_string (s,n2))</PRE>

</UL>
</UL>



<A NAME="Member Functionscopy()"></A><PRE>size_type 
<B>copy</B> (charT* s, size_type n, size_type pos = 0) const;</PRE>

<UL>
<P>Replaces elements in memory with copies of elements from this string. An <SAMP>out_of_range</SAMP> exception is thrown if <SAMP>pos &gt; size()</SAMP>. The lesser of <SAMP>n</SAMP> and <SAMP>size() - pos</SAMP> elements of this string, starting at position <SAMP>pos</SAMP>, are copied into the array pointed to by <SAMP>s</SAMP>. No terminating null is appended to <SAMP>s</SAMP>.</P>
</UL>



<A NAME="Member Functionsc_str()"></A><PRE>const charT* 
<B>c_str</B> () const;
<A NAME="Member Functionsdata()"></A>const charT* 
<B>data</B> () const;</PRE>

<UL>
<P>Returns a pointer to the initial element of an array whose first <SAMP>size()</SAMP> elements are copies of the elements in this string. A charT<SAMP>()</SAMP> element is appended to the end. The elements of the array may not be altered, and the returned pointer is only valid until a non-<SAMP>const</SAMP> member function of this string is called. If <SAMP>size()</SAMP> is zero, the <SAMP>data()</SAMP> function returns a non-<SAMP>NULL</SAMP> pointer.</P>
</UL>



<A NAME="Member Functionsempty()"></A><PRE>bool <B>empty</B> () const;</PRE>

<UL>
<P>Returns <SAMP>size() == 0</SAMP>.</P>
</UL>



<A NAME="Member Functionserase()"></A><PRE>basic_string&amp; 
<B>erase</B> (size_type pos = 0, size_type n = npos);
iterator 
<B>erase</B> (iterator p);
iterator 
<B>erase</B> (iterator first, iterator last);</PRE>

<UL>
<P>This function removes elements from the string, collapsing the remaining elements, as necessary, to remove any space left empty.</P>
<P> The first version of the function removes the smaller of <SAMP>n</SAMP> and <SAMP>size() - pos</SAMP> starting at position <SAMP>pos</SAMP>. An <SAMP>out_of_range</SAMP> exception is thrown if <SAMP>pos &gt; size()</SAMP>. </P>
<P>For the second version, <SAMP>p</SAMP> must be a valid iterator on the string, and the function removes the character referred to by <SAMP>p</SAMP>. </P>
<P>For the last version of <SAMP>erase</SAMP>, both <SAMP>first</SAMP> and <SAMP>last</SAMP> must be valid iterators on the string, and the function removes the characters defined by the range <SAMP>[first, last)</SAMP>. The destructors for all removed characters are called.   </P>
<P>All versions of <SAMP>erase</SAMP> return a reference to the string after completion.</P>
</UL>



<A NAME="Member Functionsfind()"></A><PRE>size_type 
<B>find</B> (const basic_string&amp; str, size_type pos = 0) const;</PRE>

<UL>
<P>Searches for the first occurrence of the substring specified by <SAMP>str</SAMP> in this string, starting at position <SAMP>pos</SAMP>. If found, it returns the index of the first character of the matching substring. If not found, returns <SAMP>npos</SAMP>. Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>



<PRE>size_type
<B>find</B> (const charT* s, size_type pos, size_type n) const;
size_type 
<B>find</B> (const charT* s, size_type pos = 0) const;
size_type 
<B>find</B> (charT c, size_type pos = 0) const;</PRE>

<UL>
<P>Searches for the first sequence of characters in this string that match a specified string. The variations of this function return, respectively:</P>
<UL>
<PRE>find(basic_string(s,n), pos)
find(basic_string(s), pos)
find(basic_string(1, c), pos)</PRE>

</UL>
</UL>



<A NAME="Member Functionsfind_first_not_of()"></A><PRE>size_type
<B>find_first_not_of</B> (const basic_string&amp; str,
                   size_type pos = 0) const;</PRE>

<UL>
<P>Searches for the first element of this string at or after position <SAMP>pos</SAMP> that is not equal to any element of <SAMP>str</SAMP>. If found, <SAMP>find_first_not_of</SAMP> returns the index of the non-matching character. If all of the characters match, the function returns <SAMP>npos</SAMP>. Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>



<PRE>size_type 
<B>find_first_not_of</B> (const charT* s, 
                   size_type pos, size_type n) const;
size_type 
<B>find_first_not_of</B> (const charT* s, 
                   size_type pos = 0) const;
size_type 
<B>find_first_not_of</B> (charT c, size_type pos = 0) const;</PRE>

<UL>
<P>Searches for the first element in this string at or after position <SAMP>pos</SAMP> that is not equal to any element of a given set of characters. The members return, respectively:</P>
<UL>
<PRE>find_first_not_of(basic_string(s,n), pos)
find_first_not_of(basic_string(s), pos)
find_first_not_of(basic_string(1, c), pos)</PRE>

</UL>
</UL>



<A NAME="Member Functionsfind_first_of()"></A><PRE>size_type
<B>find_first_of</B>(const basic_string&amp; str,
              size_type pos = 0) const;</PRE>

<UL>
<P>Searches for the first occurrence at or after position <SAMP>pos</SAMP> of any element of <SAMP>str</SAMP> in this string. If found, the index of this matching character is returned. If not found, <SAMP>npos</SAMP> is returned. Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>



<PRE>size_type 
<B>find_first_of</B>(const charT* s, size_type pos,
              size_type n) const;
size_type 
<B>find_first_of</B>(const charT* s, size_type pos = 0) const;
size_type
<B>find_first_of</B> (charT c, size_type pos = 0) const;</PRE>

<UL>
<P>Searches for the first occurrence in this string of any element in a specified string. The <SAMP>find_first_of</SAMP> variations return, respectively:</P>
<UL>
<PRE>find_first_of(basic_string(s,n), pos)
find_first_of(basic_string(s), pos)
find_first_of(basic_string(1, c), pos)</PRE>

</UL>
</UL>



<A NAME="Member Functionsfind_last_not_of()"></A><PRE>size_type 
<B>find_last_not_of</B>(const basic_string&amp; str,
                 size_type pos = npos) const;</PRE>

<UL>
<P>Searches for the last element of this string at or before position <SAMP>pos</SAMP> that is not equal to any element of <SAMP>str</SAMP>. If <SAMP>find_last_not_of</SAMP> finds a non-matching element, it returns the index of the character. If all the elements match, the function returns <SAMP>npos</SAMP>. Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>



<PRE>size_type 
<B>find_last_not_of</B>(const charT* s,
                 size_type pos, size_type n) const;
size_type 
<B>find_last_not_of</B>(const charT* s, size_type pos = npos) const;
size_type 
<B>find_last_not_of</B>(charT c, size_type pos = npos) const;</PRE>

<UL>
<P>Searches for the last element in this string at or before position <SAMP>pos</SAMP> that is not equal to any element of a given set of characters. The members return, respectively:</P>
<UL>
<PRE>find_last_not_of(basic_string(s,n), pos)
find_last_not_of(basic_string(s), pos)
find_last_not_of(basic_string(1, c), pos)</PRE>

</UL>
</UL>



<A NAME="Member Functionsfind_last_of()"></A><PRE>size_type 
<B>find_last_of</B>(const basic_string&amp; str,
             size_type pos = npos) const; </PRE>

<UL>
<P>Searches for the last occurrence of any element of <SAMP>str</SAMP> at or before position <SAMP>pos</SAMP> in this string. If found, <SAMP>find_last_of</SAMP> returns the index of the matching character. If not found, <SAMP>find_last_of</SAMP> returns <SAMP>npos</SAMP>. Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>



<PRE>size_type
<B>find_last_of</B>(const charT* s, size_type pos,
             size_type n) const;
size_type 
<B>find_last_of</B>(const charT* s, size_type pos = npos) const;
size_type 
<B>find_last_of</B>(charT c, size_type pos = npos) const;</PRE>

<UL>
<P>Searches for the last occurrence in this string of any element in a specified string. The members return, respectively:</P>
<UL>
<PRE>find_last_of(basic_string(s,n), pos)
find_last_of(basic_string(s), pos)
find_last_of(basic_string(1, c), pos)</PRE>

</UL>
</UL>



<A NAME="Member Functionsinsert()"></A><PRE>basic_string&amp;
<B>insert</B>(size_type pos1, const basic_string&amp; s);
basic_string&amp; 
<B>insert</B>(size_type pos, const basic_string&amp; s,
       size_type pos2 = 0, size_type n = npos);
basic_string&amp;
<B>insert</B>(size_type pos, const charT* s, size_type n);
basic_string&amp;
<B>insert</B>(size_type pos, const charT* s);
basic_string&amp; 
<B>insert</B>(size_type pos, size_type n, charT c);</PRE>

<UL>
<P>Inserts additional elements at position <SAMP>pos</SAMP> in this string. All of the variants of this function throw an <SAMP>out_of_range</SAMP> exception if <SAMP>pos &gt; size()</SAMP>. All variants also throw a <SAMP>length_error</SAMP> if the resulting strings exceed <SAMP>max_size()</SAMP>. Elements of this string are moved apart as necessary to accommodate the inserted elements. All return a reference to this string after completion.</P>
<P>The second variation of this function inserts the lesser of <SAMP>n</SAMP> and <SAMP>s.size() - pos2</SAMP> characters of <SAMP>s</SAMP>, beginning at position <SAMP>pos2</SAMP> in this string. This version throws an <SAMP>out_of_range</SAMP> exception if <SAMP>pos2 &gt; s.size()</SAMP>. </P>
<P>The third version inserts <SAMP>n</SAMP> characters of the array pointed to by <SAMP>s</SAMP>. </P>
<P>The fourth inserts elements from the array pointed to by <SAMP>s</SAMP> up to, but not including, a charT<SAMP>()</SAMP> character. </P>
<P>Finally, the fifth variation inserts <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>.</P>
</UL>



<PRE>iterator 
<B>insert</B>(iterator p, charT);
void 
<B>insert</B>(iterator p, size_type n, charT c);
template&lt;class InputIterator&gt;
void
<B>insert</B>(iterator p, InputIterator first, InputIterator last);</PRE>

<UL>
<P>Inserts additional elements in this string immediately before the character referred to by <SAMP>p</SAMP>. All of these versions of <SAMP>insert</SAMP> require that <SAMP>p</SAMP> is a valid iterator on this string. The first version inserts a copy of <SAMP>c</SAMP>. The second version inserts <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>. The third version inserts characters in the range <SAMP>[first, last).</SAMP> The first version returns <SAMP>p</SAMP>.</P>
</UL>



<A NAME="Member Functionslength()"></A><PRE>size_type 
<B>length</B>() const;</PRE>

<UL>
<P>Returns the number of elements contained in this string.</P>
</UL>



<A NAME="Member Functionsmax_size()"></A><PRE>size_type 
<B>max_size</B>() const;</PRE>

<UL>
<P>Returns the maximum possible size of the string.</P>
</UL>



<A NAME="Member Functionsrfind()"></A><PRE>size_type 
<B>rfind</B> (const basic_string&amp; str, size_type pos = npos) const;</PRE>

<UL>
<P>Searches for the last occurrence of the substring specified by <SAMP>str</SAMP> in the string, where the index of the first character of the substring is less than <SAMP>pos</SAMP>. If found, the index of the first character that matches substring is returned. If not found, <SAMP>npos</SAMP> is returned. Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>



<PRE>size_type 
<B>rfind</B>(const charT* s, size_type pos, size_type n) const;
size_type 
<B>rfind</B>(const charT* s, size_type pos = npos) const;
size_type 
<B>rfind</B>(charT c, size_type pos = npos) const;</PRE>

<UL>
<P>Searches for the last sequence of characters in this string matching a specified string. The <SAMP>rfind</SAMP> variations return, respectively:</P>
<UL>
<PRE>rfind(basic_string(s,n), pos)
rfind(basic_string(s), pos)
rfind(basic_string(1, c), pos)</PRE>

</UL>
</UL>



<A NAME="Member Functionsreplace()"></A><PRE>basic_string&amp;
<B>replace</B>(size_type pos, size_type n1, const basic_string&amp; s);
basic_string&amp; 
<B>replace</B>(size_type pos1, size_type n1, 
        const basic_string&amp; str,
        size_type pos2, size_type n2);
basic_string&amp; 
<B>replace</B>(size_type pos, size_type n1, const charT* s,
        size_type n2);
basic_string&amp; 
<B>replace</B>(size_type pos, size_type n1, const charT* s);
basic_string&amp; 
<B>replace</B>(size_type pos, size_type n1, size_type n2, charT c);</PRE>

<UL>
<P>The <SAMP>replace</SAMP> function replaces selected elements of this string with an alternate set of elements. All of these versions insert the new elements in place of <SAMP>n1</SAMP> elements in this string, starting at position <SAMP>pos</SAMP>. They each throw an <SAMP>out_of_range</SAMP> exception if <SAMP>pos1 &gt; size()</SAMP> and a <SAMP>length_error</SAMP> exception if the resulting string size exceeds <SAMP>max_size()</SAMP>.</P>
<P>The second version replaces elements of the original string with <SAMP>n2</SAMP> characters from string <SAMP>s</SAMP> starting at position <SAMP>pos2</SAMP>. It throws the <SAMP>out_of_range</SAMP> exception if <SAMP>pos2 &gt; s.size().</SAMP> The third variation of the function replaces elements in the original string with <SAMP>n2</SAMP> elements from the array pointed to by <SAMP>s</SAMP>. The fourth version replaces elements in the string with elements from the array pointed to by <SAMP>s</SAMP>, up to, but not including, a charT<SAMP>()</SAMP> character. The fifth replaces <SAMP>n</SAMP> elements with <SAMP>n2</SAMP> repetitions of character <SAMP>c</SAMP>.</P>
</UL>



<PRE>basic_string&amp; 
<B>replace</B>(iterator i1, iterator i2, 
        const basic_string&amp; str);
basic_string&amp; 
<B>replace</B>(iterator i1, iterator i2, const charT* s,
        size_type n);
basic_string&amp; 
<B>replace</B>(iterator i1, iterator i2, const charT* s);
basic_string&amp; 
<B>replace</B>(iterator i1, iterator i2, size_type n,
        charT c);
template&lt;class InputIterator&gt;
basic_string&amp; 
<B>replace</B>(iterator i1, iterator i2,
        InputIterator j1, InputIterator j2);</PRE>

<UL>
<P>Replaces selected elements of this string with an alternative set of elements. All of these versions of <SAMP>replace</SAMP> require iterators <SAMP>i1</SAMP> and <SAMP>i2</SAMP> to be valid iterators on this string. The elements specified by the range <SAMP>[i1, i2)</SAMP> are replaced by the new elements.</P>
<P>The first version shown here replaces all members in <SAMP>str</SAMP>. </P>
<P>The second version starts at position <SAMP>i1</SAMP>, and replaces the next <SAMP>n</SAMP> characters with <SAMP>n</SAMP> characters of the array pointed to by <SAMP>s</SAMP>. </P>
<P>The third variation replaces string elements with elements from the array pointed to by <SAMP>s</SAMP> up to, but not including, a <SAMP></SAMP>charT<SAMP>()</SAMP> character.</P>
<P>The fourth version replaces string elements with <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>.</P>
<P>The last variation shown here replaces string elements with the members specified in the range <SAMP>[j1, j2)</SAMP>.</P>
</UL>



<A NAME="Member Functionsreserve()"></A><PRE>void 
<B>reserve</B>(size_type res_arg=0);</PRE>

<UL>
<P>Assures that the storage capacity is at least <SAMP>res_arg</SAMP>. Throws a <SAMP>length_error</SAMP> exception if res_arg <SAMP>&gt; max_size()</SAMP>.</P>
</UL>



<A NAME="Member Functionsresize()"></A><PRE>void
<B>resize</B>(size_type n, charT c);
void
<B>resize</B>(size_type n);</PRE>

<UL>
<P>Changes the capacity of this string to <SAMP>n</SAMP>. If the new capacity is smaller than the current size of the string, then the string is truncated. If the capacity is larger, then the string is padded with <SAMP>c</SAMP> characters. The latter <SAMP>resize</SAMP> member pads the string with default characters specified by charT<SAMP>()</SAMP>. Throws a <SAMP>length_error</SAMP> exception if <SAMP>n &gt; max_size()</SAMP>.</P>
</UL>



<A NAME="Member Functionssize()"></A><PRE>size type
<B>size</B>() const;</PRE>

<UL>
<P>Return the number of elements contained in this string.</P>
</UL>



<A NAME="Member Functionssubstr()"></A><PRE>basic_string 
<B>substr</B>(size_type pos = 0, size_type n = npos) const;</PRE>

<UL>
<P>Returns a string composed of copies of the lesser of <SAMP>n</SAMP> and <SAMP>size()</SAMP> characters in this string starting at index <SAMP>pos</SAMP>. Throws an <SAMP>out_of_range</SAMP> exception if <SAMP>pos &gt; size().</SAMP></P>
</UL>



<A NAME="Member Functionsswap()"></A><PRE>void 
<B>swap</B>(basic_string&amp; s);</PRE>

<UL>
<P>Swaps the contents of this string with the contents of <SAMP>s</SAMP>.</P>
</UL>


<A NAME="Non-member Operators"><H3>Non-member Operators</H3></A>


<PRE>template&lt;class charT, class traits, class Allocator&gt;
<A NAME="Non-member Operatorsoperator+()"></A>basic_string 
<B>operator+</B>(const basic_string&amp; lhs, const basic_string&amp; rhs);</PRE>

<UL>
<P>Returns a string of length <SAMP>lhs.size() + rhs.size()</SAMP>, where the first <SAMP>lhs.size()</SAMP> elements are copies of the elements of <SAMP>lhs</SAMP>, and the next <SAMP>rhs.size()</SAMP> elements are copies of the elements of <SAMP>rhs</SAMP>.</P>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
basic_string
<B>operator+</B>(const charT* lhs, const basic_string&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
basic_string
<B>operator+</B>(charT lhs, const basic_string&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
basic_string 
<B>operator+</B>(const basic_string&amp; lhs, const charT* rhs);
template&lt;class charT, class traits, class Allocator&gt;
basic_string 
<B>operator+</B>(const basic_string&amp; lhs, charT rhs);</PRE>

<UL>
<P>Returns a string that represents the concatenation of two string-like entities. These functions return, respectively:</P>
<UL>
<PRE>basic_string(lhs) + rhs
basic_string(1, lhs) + rhs
lhs + basic_string(rhs)
lhs + basic_string(1, rhs)</PRE>

</UL>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
<A NAME="Non-member Operatorsoperator==()"></A>bool 
<B>operator==</B>(const basic_string&amp; lhs, 
           const basic_string&amp; rhs);</PRE>

<UL>
<P>Returns a boolean value of <SAMP>true</SAMP> if <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP> are equal, and <SAMP>false</SAMP> if they are not. Equality is defined by the <SAMP>compare()</SAMP> member function.</P>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
bool   
<B>operator==</B>(const charT* lhs, const basic_string&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
bool 
<B>operator==</B>(const basic_string&amp; lhs, const charT* rhs);</PRE>

<UL>
<P>Returns a boolean value indicating whether <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP> are equal. Equality is defined by the <SAMP>compare()</SAMP> member function. These functions return, respectively:</P>
<UL>
<PRE>basic_string(lhs) == rhs
lhs == basic_string(rhs)</PRE>

</UL>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
<A NAME="Non-member Operatorsoperator!=()"></A>bool 
<B>operator!=</B>(const basic_string&amp; lhs,
           const basic_string&amp; rhs);</PRE>

<UL>
<P>Returns a boolean value representing the inequality of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>. Inequality is defined by the <SAMP>compare()</SAMP> member function.</P>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
bool 
<B>operator!=</B>(const charT* lhs, const basic_string&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
bool 
<B>operator!=</B>(const basic_string&amp; lhs, const charT* rhs);</PRE>

<UL>
<P>Returns a boolean value representing the inequality of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>. Inequality is defined by the <SAMP>compare()</SAMP> member function. The functions return, respectively:</P>
<UL>
<PRE>basic_string(lhs) != rhs
lhs != basic_string(rhs)</PRE>

</UL>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
<A NAME="Non-member Operatorsoperator&lt;()"></A>bool 
<B>operator&lt;</B>(const basic_string&amp; lhs, const basic_string&amp; rhs);</PRE>

<UL>
<P>Returns a boolean value representing the lexicographical less-than relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>. Less-than is defined by the <SAMP>compare()</SAMP> member.</P>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
bool 
<B>operator&lt;</B>(const charT* lhs, const basic_string&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
bool 
<B>operator&lt;</B>(const basic_string&amp; lhs, const charT* rhs);</PRE>

<UL>
<P>Returns a boolean value representing the lexicographical less-than relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>. Less-than is defined by the <SAMP>compare()</SAMP> member function. These functions return, respectively:</P>
<UL>
<PRE>basic_string(lhs) &lt; rhs
lhs &lt; basic_string(rhs)</PRE>

</UL>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
<A NAME="Non-member Operatorsoperator&gt;()"></A>bool 
<B>operator&gt;</B>(const basic_string&amp; lhs, const basic_string&amp; rhs);</PRE>

<UL>
<P>Returns a boolean value representing the lexicographical greater-than relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>. Greater-than is defined by the <SAMP>compare()</SAMP> member function.</P>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
bool 
<B>operator&gt;</B>(const charT* lhs, const basic_string&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
bool 
<B>operator&gt;</B>(const basic_string&amp; lhs, const charT* rhs);</PRE>

<UL>
<P>Returns a boolean value representing the lexicographical greater-than relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>. Greater-than is defined by the <SAMP>compare()</SAMP> member. The functions return, respectively:</P>
<UL>
<PRE>basic_string(lhs) &gt; rhs
lhs &gt; basic_string(rhs)</PRE>

</UL>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
<A NAME="Non-member Operatorsoperator&lt;=()"></A>bool 
<B>operator&lt;=</B>(const basic_string&amp; lhs,
             const basic_string&amp; rhs);</PRE>

<UL>
<P>Returns a boolean value representing the lexicographical less-than-or-equal relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>. Less-than-or-equal is defined by the <SAMP>compare()</SAMP> member function.</P>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
bool   
<B>operator&lt;=</B>(const charT* lhs, const basic_string&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
bool 
<B>operator&lt;=</B>(const basic_string&amp; lhs, const charT* rhs);</PRE>

<UL>
<P>Returns a boolean value representing the lexicographical less-than-or-equal relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>. Less-than-or-equal is defined by the <SAMP>compare()</SAMP> member function. These functions return, respectively:</P>
<UL>
<PRE>basic_string(lhs) &lt;= rhs
lhs &lt;= basic_string(rhs)</PRE>

</UL>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
<A NAME="Non-member Operatorsoperator&gt;=()"></A>bool 
<B>operator&gt;=</B>(const basic_string&amp; lhs, 
           const basic_string&amp; rhs);</PRE>

<UL>
<P>Returns a boolean value representing the lexicographical greater-than-or-equal relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>. Greater-than-or-equal is defined by the <SAMP>compare()</SAMP> member function.</P>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
bool 
<B>operator&gt;=</B>(const charT* lhs, const basic_string&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
bool 
<B>operator&gt;=</B>(const basic_string&amp; lhs, const charT* rhs);</PRE>

<UL>
<P>Returns a boolean value representing the lexicographical greater-than-or-equal relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>. Greater-than-or-equal is defined by the <SAMP>compare()</SAMP> member. The functions return, respectively:</P>
<UL>
<PRE>basic_string(lhs) &gt;= rhs
lhs &gt;= basic_string(rhs)</PRE>

</UL>
</UL>



<PRE>template &lt;class charT, class traits, class Allocator&gt;
void <B>swap</B>(basic_string&lt;charT,traits,Allocator&gt;&amp; a, 
          basic_string&lt;charT,traits,Allocator&gt;&amp; b); </PRE>

<UL>
<P>Swaps the contents of <SAMP>a</SAMP> and <SAMP>b</SAMP> by calling <SAMP>a</SAMP>'s swap function on <SAMP>b</SAMP>.</P>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
<A NAME="Non-member Operatorsoperator&gt;&gt;()"></A>basic_istream&lt;charT, traits&gt;&amp;
<B>operator&gt;&gt;</B>(basic_istream&lt;charT, traits&gt;&amp; is, 
           basic_string&amp; str);</PRE>

<UL>
<P>Reads <SAMP>str</SAMP> from <SAMP>is</SAMP> using <SAMP>traits::char_in</SAMP> until a <SAMP>traits::is_del()</SAMP> element is read. All elements read, except the delimiter, are placed in <SAMP>str</SAMP>. After the read, the function returns <SAMP>is</SAMP>.</P>
</UL>



<PRE>template&lt;class charT, class traits, class Allocator&gt;
<A NAME="Non-member Operatorsoperator&lt;&lt;()"></A>basic_ostream&lt;charT, traits&gt;&amp;
<B>operator&lt;&lt;</B>(basic_ostream &lt;charT, traits&gt;&amp; os, 
           const&lt;charT, traits allocator&gt; str);</PRE>

<UL>
<P>Writes all elements of <SAMP>str</SAMP> to <SAMP>os</SAMP> in order from first to last, using <SAMP>traits::char_out()</SAMP>. After the write, the function returns <SAMP>os</SAMP>.</P>
</UL>


<A NAME="Non-member Functions"><H3>Non-member Functions</H3></A>


<PRE>template &lt;class Stream, class charT, class traits,
          class Allocator&gt;
<A NAME="Non-member Functionsgetline()"></A>basic_istream&lt;charT, traits&gt;
<B>getline</B>(basic_istream&lt;charT, traits&gt; is, 
        &lt;charT, traits allocator&gt; str, charT delim);</PRE>

<UL>
<P>An unformatted input function that extracts characters from <SAMP>is</SAMP> into <SAMP>str</SAMP> until <SAMP>npos - 1</SAMP> characters are read, the end of the input sequence is reached, or the character read is <SAMP>delim</SAMP>. The characters are read using <SAMP>traits::char_in()</SAMP>. </P>
</UL>


<A NAME="Example"><H3>Example</H3></A>
<UL>
<PRE>//
// string.cpp
//
 #include&lt;string&gt;
 #include &lt;iostream&gt;
 using namespace std;

 int main()
 {
   string test;

   //Type in a string over five characters long
   while(test.empty() || test.size() &lt;= 5)
   {
     cout &lt;&lt; "Type a string between 5 and 100
              characters long. " &lt;&lt; endl;
     cin &gt;&gt; test;
   }

   //Test operator[] access
   cout &lt;&lt; "Changing the third character from " 
        &lt;&lt; test[2] &lt;&lt; " to * " &lt;&lt; endl;
   test[2] = '*';
   cout &lt;&lt; "now its: " &lt;&lt; test &lt;&lt; endl &lt;&lt; endl;

   //Try the insertion member function
   cout &lt;&lt; "Identifying the middle: ";
   test.insert(test.size() / 2, "(the middle is here!)");
   cout &lt;&lt; test &lt;&lt; endl &lt;&lt; endl;


   //Try replacement
   cout &lt;&lt; "I didn't like the word 'middle',so "
           "instead, I'll say:" &lt;&lt; endl;

   test.replace(test.find("middle",0), 6, "center");
   cout &lt;&lt; test &lt;&lt; endl; 

   return 0;
 }</PRE>

</UL>
<P><B>Program Output</B></P>
<UL>
<PRE>
Type a string between 5 and 100 characters long.
roguewave
Changing the third character from g to *
now its: ro*uewave
Identifying the middle: ro*u(the middle is here!)ewave
I didn't like the word 'middle', so instead, I'll say:
ro*u(the center is here!)ewave</PRE>

</UL>

<A NAME="See Also"><H3>See Also</H3></A>
<P><B><I><A HREF="all_7029.htm">allocator</A></I></B>, <B><I><A HREF="str_8586.htm">string</A></I></B></P>


<BR>
<HR>
<A HREF="bas_0582.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="bas_3672.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<BR>&copy;Copyright 1999, Rogue Wave Software, Inc.<BR>Send <A HREF="mailto:onlinedocs@roguewave.com">mail</A> to report errors or comment on the documentation.
<BR>
OEM Release</BODY></HTML>
