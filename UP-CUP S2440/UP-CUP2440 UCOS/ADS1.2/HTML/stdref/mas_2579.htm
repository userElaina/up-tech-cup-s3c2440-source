<HTML><HEAD><TITLE>mask_array</TITLE></HEAD><BODY BGCOLOR=#FFFFFF>
<IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0><BR>
<A HREF="map_8018.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="max_6671.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><BR>

<H2>mask_array</H2>
<PRE><HR>Valarray helpers
<HR></PRE>
<UL>
<LI><A HREF="#Summary">Summary</A></LI>
<LI><A HREF="#memindex">Data Type and Member Function Indexes</A></LI>
<LI><A HREF="#Synopsis">Synopsis</A></LI>
<LI><A HREF="#Description">Description</A></LI>
<LI><A HREF="#Interface">Interface</A></LI>
<LI><A HREF="#Constructors">Constructors</A></LI>
<LI><A HREF="#Assignment Operators">Assignment Operators</A></LI>
<LI><A HREF="#Computed Assignment Operators">Computed Assignment Operators</A></LI>
<LI><A HREF="#Member Functions">Member Functions</A></LI>
<LI><A HREF="#Example">Example</A></LI>
<LI><A HREF="#Warnings">Warnings</A></LI>
<LI><A HREF="#See Also">See Also</A></LI>

</UL>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A numeric array class that gives a masked view of a valarray.</P>
<A NAME="memindex"><H3>Data Type and Member Function Indexes<BR>(exclusive of constructors and destructors)</H3></A>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Member Functions</B></TD></TR><TR><TD VALIGN=top><A HREF="#Computed Assignment Operatorsoperator%=()">operator%=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator&amp;=()">operator&amp;=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator&gt;&gt;=()">operator&gt;&gt;=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator&lt;&lt;=()">operator&lt;&lt;=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator*=()">operator*=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator+=()">operator+=()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Computed Assignment Operatorsoperator-=()">operator-=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator/=()">operator/=()</A><BR>
 <A HREF="#Assignment Operatorsoperator=()">operator=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator^=()">operator^=()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>
<PRE>#include &lt;valarray&gt;
template &lt;class T&gt;
class <B>mask_array</B>;</PRE>

</PRE>

<A NAME="Description"><H3>Description</H3></A>
<P><B><I>mask_array&lt;T&gt;</I></B> gives a masked view into a <B><I><A HREF="val_6244.htm">valarray</A></I></B>. <B><I>mask_arrays</I></B> are only produced by applying the mask subscript operator to a <B><I>valarray</I></B>. This subscript operator takes a <SAMP>valarray&lt;bool&gt;</SAMP> argument and produces a <B><I>mask_array</I></B>. Only the elements in the <B><I>valarray</I></B> whose corresponding elements in the <SAMP>valarray&lt;bool&gt;</SAMP> argument were <SAMP>true</SAMP> are selected by the <B><I>mask_array</I></B>. The elements in a <B><I>mask_array</I></B> are references to selected elements in the <B><I>valarray</I></B> (so changing an element in the <B><I>mask_array</I></B> really changes the corresponding element in the <B><I>valarray</I></B>). A <B><I>mask_array</I></B> does not itself hold any distinct elements. The template cannot be instantiated directly since all its constructors are private. However, you can copy a <B><I><A HREF="sli_1044.htm">slice_array</A></I></B> to a <B><I>valarray</I></B> using either the <B><I>valarray</I></B> copy constructor or the assignment operator. Reference semantics are lost at that point. </P>

<A NAME="Interface"><H3>Interface</H3></A>
<PRE>
<PRE>template &lt;class T&gt; class mask_array {
public:

  // types
  typedef T value_type;

  // destructor
  ~mask_array();

  // public assignment
  void operator= (const valarray&lt;T&gt;&amp; array) const;
  // computed assignment
  void operator*= (const valarray&lt;T&gt;&amp; array) const;
  void operator/= (const valarray&lt;T&gt;&amp; array) const;
  void operator%= (const valarray&lt;T&gt;&amp; array) const;
  void operator+= (const valarray&lt;T&gt;&amp; array) const;
  void operator-= (const valarray&lt;T&gt;&amp; array) const;
  void operator^= (const valarray&lt;T&gt;&amp; array) const;
  void operator&amp;= (const valarray&lt;T&gt;&amp; array) const;
  void operator|= (const valarray&lt;T&gt;&amp; array) const;
  void operator&lt;&lt;= (const valarray&lt;T&gt;&amp; array) const;
  void operator&gt;&gt;= (const valarray&lt;T&gt;&amp; array) const;
 
  // other
  void operator= (const T&amp;) const; 

private:
  // constructors
  mask_array();
  mask_array(const mask_array&lt;T&gt;&amp;);
  // operator =
  mask_array&lt;T&gt;&amp; operator= (const mask_array&lt;T&gt;&amp; array);
};</PRE>

</PRE>

<A NAME="Constructors"><H3>Constructors</H3></A>


<PRE><B>mask_array</B>();
<B>mask_array</B>(const mask_array&amp;);</PRE>

<UL>
<P>All mask_array constructors are private and cannot be called directly. This prevents copy construction of mask_arrays.</P>
</UL>


<A NAME="Assignment Operators"><H3>Assignment Operators</H3></A>


<A NAME="Assignment Operatorsoperator=()"></A><PRE>void <B>operator=</B>(const valarray&lt;T&gt;&amp; x) const;</PRE>

<UL>
<P>Assigns values from <SAMP>x</SAMP> to the selected elements of the valarray that self refers to. Remember that a mask_array never holds any elements itself, it simply refers to selected elements in the valarray used to generate it.</P>
</UL>



<PRE>mask_array&lt;T&gt;&amp; 
<B>operator=</B>(const mask-_array&lt;T&gt;&amp; x);</PRE>

<UL>
<P>Private assignment operator. Cannot be called directly, thus preventing assignment between mask_arrays.</P>
</UL>


<A NAME="Computed Assignment Operators"><H3>Computed Assignment Operators</H3></A>


<A NAME="Computed Assignment Operatorsoperator*=()"></A><PRE>void <B>operator*=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator/=()"></A>void <B>operator/=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator%=()"></A>void <B>operator%=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator+=()"></A>void <B>operator+=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator-=()"></A>void <B>operator-=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator^=()"></A>void <B>operator^=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator&amp;=()"></A>void <B>operator&amp;=</B>(const valarray&lt;T&gt;&amp; val) const;
void <B>operator|=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator&lt;&lt;=()"></A>void <B>operator&lt;&lt;=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator&gt;&gt;=()"></A>void <B>operator&gt;&gt;=</B>(const valarray&lt;T&gt;&amp; val) const;</PRE>

<UL>
<P>Applies the indicated operation using elements from <SAMP>val</SAMP> to the selected elements of the valarray that self refers to. Remember that a mask_array never holds any elements itself; it simply refers to selected elements in the valarray used to generate it.</P>
</UL>


<A NAME="Member Functions"><H3>Member Functions</H3></A>


<PRE>void <B>operator=</B> (const T&amp; x) const;</PRE>

<UL>
<P>Assigns <SAMP>x</SAMP> to the selected elements of the valarray that self refers to. </P>
</UL>


<A NAME="Example"><H3>Example</H3></A>
<UL>
<PRE>//
// mask_array.cpp
//
#include "valarray.h" // Contains a valarray stream inserter
using namespace std;

int main(void)
{
  int ibuf[10] = {0,1,2,3,4,5,6,7,8,9};
  bool mbuf[10] = {1,0,1,1,1,0,0,1,1,0};

  // create a valarray of ints
  valarray&lt;int&gt;         vi(ibuf,10);

  // create a valarray of bools for a mask
  valarray&lt;bool&gt; mask(mbuf,10);

  // print out the valarray&lt;int&gt;
  cout &lt;&lt; vi &lt;&lt; endl;

  // Get a mask array and assign that mask to another array
  mask_array&lt;int&gt; msk = vi[mask];
  valarray&lt;int&gt; vi3 = msk;

  // print out the masked_array
  cout &lt;&lt; vi3 &lt;&lt; endl;

  // Double the masked values
  msk += vi3;

  // print out vi1 again
  cout &lt;&lt; vi &lt;&lt; endl;

  return 0;
}</PRE>

</UL>
<P><B>Program Output</B></P>
<UL>
<PRE>
[0,1,2,3,4,5,6,7,8,9]
[0,2,3,4,7,8]
[0,1,4,6,8,5,6,14,16,9]</PRE>

</UL>

<A NAME="Warnings"><H3>Warnings</H3></A>
<P>If your compiler does not support namespaces, then you do not need the using declaration for <SAMP>std</SAMP>.</P>

<A NAME="See Also"><H3>See Also</H3></A>
<P><B><I><A HREF="val_6244.htm">valarray</A></I></B>, <B><I><A HREF="sli_1044.htm">slice_array</A></I></B>, <B><I><A HREF="sli_0626.htm">slice</A></I></B>, <B><I><A HREF="gsl_4121.htm">gslice</A></I></B>, <B><I><A HREF="gsl_1439.htm">gslice_array</A></I></B>, <B><I><A HREF="ind_9304.htm">indirect_array</A></I></B></P>


<BR>
<HR>
<A HREF="map_8018.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="max_6671.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<BR>&copy;Copyright 1999, Rogue Wave Software, Inc.<BR>Send <A HREF="mailto:onlinedocs@roguewave.com">mail</A> to report errors or comment on the documentation.
<BR>
OEM Release</BODY></HTML>
