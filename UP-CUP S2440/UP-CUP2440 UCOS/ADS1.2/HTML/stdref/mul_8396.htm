<HTML><HEAD><TITLE>multimap</TITLE></HEAD><BODY BGCOLOR=#FFFFFF>
<IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0><BR>
<A HREF="mon_8228.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="mul_0796.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><BR>

<H2>multimap</H2>
<PRE><HR>Container
<HR></PRE>
<UL>
<LI><A HREF="#Summary">Summary</A></LI>
<LI><A HREF="#memindex">Data Type and Member Function Indexes</A></LI>
<LI><A HREF="#Synopsis">Synopsis</A></LI>
<LI><A HREF="#Description">Description</A></LI>
<LI><A HREF="#Interface">Interface</A></LI>
<LI><A HREF="#Constructors">Constructors</A></LI>
<LI><A HREF="#Destructors">Destructors</A></LI>
<LI><A HREF="#Assignment Operators">Assignment Operators</A></LI>
<LI><A HREF="#Allocators">Allocators</A></LI>
<LI><A HREF="#Iterators">Iterators</A></LI>
<LI><A HREF="#Member Functions">Member Functions</A></LI>
<LI><A HREF="#Non-member Operators">Non-member Operators</A></LI>
<LI><A HREF="#Specialized Algorithms">Specialized Algorithms</A></LI>
<LI><A HREF="#Example">Example</A></LI>
<LI><A HREF="#Warnings">Warnings</A></LI>
<LI><A HREF="#See Also">See Also</A></LI>

</UL>
<A NAME="Summary"><H3>Summary</H3></A>
<P>An associative container that gives access to non-key values using keys. <B><I>multimap</I></B> keys are not required to be unique. A <B><I>multimap</I></B> supports bidirectional iterators.</P>
<A NAME="memindex"><H3>Data Type and Member Function Indexes<BR>(exclusive of constructors and destructors)</H3></A>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Member Functions</B></TD></TR><TR><TD VALIGN=top><A HREF="#Iteratorsbegin()">begin()</A><BR>
 <A HREF="#Member Functionsclear()">clear()</A><BR>
 <A HREF="#Member Functionscount()">count()</A><BR>
 <A HREF="#Member Functionsempty()">empty()</A><BR>
 <A HREF="#Iteratorsend()">end()</A><BR>
 <A HREF="#Member Functionsequal_range()">equal_range()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Functionserase()">erase()</A><BR>
 <A HREF="#Member Functionsfind()">find()</A><BR>
 <A HREF="#Allocatorsget_allocator()">get_allocator()</A><BR>
 <A HREF="#Member Functionsinsert()">insert()</A><BR>
 <A HREF="#Member Functionskey_comp()">key_comp()</A><BR>
 <A HREF="#Member Functionslower_bound()">lower_bound()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Functionsmax_size()">max_size()</A><BR>
 <A HREF="#Non-member Operatorsoperator!=()">operator!=()</A><BR>
 <A HREF="#Non-member Operatorsoperator&gt;()">operator&gt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&gt;=()">operator&gt;=()</A><BR>
 <A HREF="#Non-member Operatorsoperator&lt;()">operator&lt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&lt;=()">operator&lt;=()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Assignment Operatorsoperator=()">operator=()</A><BR>
 <A HREF="#Non-member Operatorsoperator==()">operator==()</A><BR>
 <A HREF="#Iteratorsrbegin()">rbegin()</A><BR>
 <A HREF="#Iteratorsrend()">rend()</A><BR>
 <A HREF="#Member Functionssize()">size()</A><BR>
 <A HREF="#Member Functionsswap()">swap()</A><BR>
 <A HREF="#Member Functionsupper_bound()">upper_bound()</A><BR>
 <A HREF="#Member Functionsvalue_comp()">value_comp()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>
<PRE>#include &lt;map&gt;
template &lt;class Key, class T, class Compare = less&lt;Key&gt;,
          class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt; &gt;
class <B>multimap</B>;</PRE>

</PRE>

<A NAME="Description"><H3>Description</H3></A>
<P><B><I>multimap &lt;Key ,T, Compare, Allocator&gt;</I></B> gives fast access to stored values of type <SAMP>T</SAMP> that are indexed by keys of type <SAMP>Key</SAMP>. The default operation for key comparison is the <SAMP>&lt;</SAMP> operator. Unlike <B><I><A HREF="map_8018.htm">map</A></I></B>, <B><I>multimap</I></B> allows insertion of duplicate keys. </P>
<P><B><I>multimap</I></B> uses bidirectional iterators that point to an instance of <SAMP>pair&lt;const Key x, T y&gt;</SAMP> where <SAMP>x</SAMP> is the key and <SAMP>y</SAMP> is the stored value associated with that key.   The definition of <B><I>multimap</I></B> includes a <SAMP>typedef</SAMP> to this pair called <SAMP>value_type</SAMP>. </P>
<P>The types used for both the template parameters <SAMP>Key</SAMP> and <SAMP>T</SAMP> must include the following (where <SAMP>T</SAMP> is the <SAMP>type</SAMP>, <SAMP>t</SAMP> is a value of <SAMP>T</SAMP> and <SAMP>u</SAMP> is a <SAMP>const</SAMP> <SAMP>value</SAMP> of <SAMP>T</SAMP>): </P>
<TABLE>
<TR><TD VALIGN=top>Copy constructors  </TD>
<TD><SAMP>T(t)</SAMP> and <SAMP>T(u)</SAMP></TD></TR>
<TR><TD VALIGN=top>Destructor  </TD>
<TD><SAMP>t.~T()</SAMP></TD></TR>
<TR><TD VALIGN=top>Address of  </TD>
<TD><SAMP>&amp;t</SAMP> and <SAMP>&amp;u</SAMP> yielding <SAMP>T*</SAMP> and <SAMP>const T*</SAMP> respectively</TD></TR>
<TR><TD VALIGN=top>Assignment  </TD>
<TD><SAMP>t = a</SAMP> where <SAMP>a</SAMP> is a (possibly <SAMP>const</SAMP>) value of <SAMP>T</SAMP></TD></TR>
</TABLE>
<P>The type used for the <SAMP>Compare</SAMP> template parameter must satisfy the requirements for binary functions.</P>

<A NAME="Interface"><H3>Interface</H3></A>
<PRE>
<PRE>template &lt;class Key, class T, class Compare = less&lt;Key&gt;,
          class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt; &gt;
 class multimap {

public:

// types

   typedef Key key_type;
   typedef T mapped_type;
   typedef pair&lt;const Key, T&gt; value_type;
   typedef Compare key_compare;
   typedef Allocator allocator_type;</PRE>

<UL>
<PRE>
   typedef typename
           Allocator::reference        reference;
   typedef typename
           Allocator::const_reference  const_reference;</PRE>

</UL>
<PRE>   class iterator;
   class const_iterator;</PRE>

<UL>
<PRE>   typedef typename
           Allocator::size_type        size_type;
   typedef typename
           Allocator::difference_type  difference_type;</PRE>

</UL>
<PRE>   typedef typename std::reverse_iterator&lt;iterator&gt;
                         reverse_iterator;
   typedef typename std::reverse_iterator&lt;const_iterator&gt;
                         const_reverse_iterator;
</PRE>

<UL>
<PRE> class value_compare
    : public binary_function&lt;value_type, value_type, bool&gt; </PRE>

</UL>
<PRE>    {
     friend class multimap&lt;Key, T, Compare, Allocator&gt;;

     protected :
       Compare comp;
       value_compare (Compare C) : comp(c) {}
     public :
       bool operator() (const value_type&amp;, 
                        const value_type&amp;) const;
    };

// Construct/Copy/Destroy

   explicit multimap (const Compare&amp; = Compare(), 
                      const Allocator&amp; = 
                      Allocator());
   template &lt;class InputIterator&gt;
    multimap (InputIterator, InputIterator,
              const Compare&amp; = Compare(),
              const Allocator&amp; = Allocator());
   multimap (const multimap&lt;Key, T, Compare, Allocator&gt;&amp;);
   ~multimap ();
   multimap&lt;Key, T, Compare, Allocator&gt;&amp; operator=
       (const multimap&lt;Key, T, Compare, Allocator&gt;&amp;);
   allocator_type get_allocator () const;

// Iterators

   iterator begin ();
   const_iterator begin () const;
   iterator end ();
   const_iterator end () const;
   reverse_iterator rbegin ();
   const_reverse_iterator rbegin () const;
   reverse_iterator rend ();
   const_reverse_iterator rend () const;

// Capacity

   bool empty () const;
   size_type size () const;
   size_type max_size () const;

// Modifiers

   iterator insert (const value_type&amp;);
   iterator insert (iterator, const value_type&amp;);
   template &lt;class InputIterator&gt;
    void insert (InputIterator, InputIterator);

   void erase (iterator);
   size_type erase (const key_type&amp;);
   void erase (iterator, iterator);
   void swap (multimap&lt;Key, T, Compare, Allocator&gt;&amp;);
   void clear ();

// Observers

   key_compare key_comp () const;
   value_compare value_comp () const;

// Multimap operations

   iterator find (const key_type&amp;);
   const_iterator find (const key_type&amp;) const;
   size_type count (const key_type&amp;) const;

   iterator lower_bound (const key_type&amp;);
   const_iterator lower_bound (const key_type&amp;) const;
   iterator upper_bound (const key_type&amp;);
   const_iterator upper_bound (const key_type&amp;) const;
   pair&lt;iterator, iterator&gt; equal_range (const key_type&amp;);
   pair&lt;const_iterator, const_iterator&gt; 
     equal_range (const key_type&amp;) const;
};
// Non-member Operators

template &lt;class Key, class T, class Compare, 
          class Allocator&gt;
 bool operator== (const multimap&lt;Key, T, Compare,
                  Allocator&gt;&amp;,
                  const multimap&lt;Key, T, Compare,
                  Allocator&gt;&amp;);

template &lt;class Key, class T, class Compare, 
          class Allocator&gt;
 bool operator!= (const multimap&lt;Key, T, Compare,
                  Allocator&gt;&amp;,
                  const multimap&lt;Key, T, Compare,
                  Allocator&gt;&amp;);

template &lt;class Key, class T, class Compare, 
          class Allocator&gt;
 bool operator&lt; (const multimap&lt;Key, T, Compare,
                 Allocator&gt;&amp;,
                 const multimap&lt;Key, T, Compare,
                 Allocator&gt;&amp;);

template &lt;class Key, class T, class Compare, 
          class Allocator&gt;
 bool operator&gt; (const multimap&lt;Key, T, Compare,
                 Allocator&gt;&amp;,
                 const multimap&lt;Key, T, Compare,
                 Allocator&gt;&amp;);

template &lt;class Key, class T, class Compare, 
          class Allocator&gt;
 bool operator&lt;= (const multimap&lt;Key, T, Compare,
                  Allocator&gt;&amp;,
                  const multimap&lt;Key, T, Compare,
                  Allocator&gt;&amp;);

template &lt;class Key, class T, class Compare, 
          class Allocator&gt;
 bool operator&gt;= (const multimap&lt;Key, T, Compare,
                  Allocator&gt;&amp;,
                  const multimap&lt;Key, T, Compare,
                  Allocator&gt;&amp;);

// Specialized Algorithms

template &lt;class Key, class T, class Compare, 
          class Allocator&gt;
 void swap (multimap&lt;Key, T, Compare, Allocator&gt;&amp;,
            multimap&lt;Key, T, Compare, Allocator&gt;&amp;;</PRE>

</PRE>

<A NAME="Constructors"><H3>Constructors</H3></A>


<PRE>explicit <B>multimap</B>(const Compare&amp; comp = Compare(),
                  const Allocator&amp; alloc = Allocator());</PRE>

<UL>
<P>Constructs an empty multimap that uses the optional relation <SAMP>comp</SAMP> to order keys and the allocator <SAMP>alloc</SAMP> for all storage management.</P>
</UL>



<PRE>template &lt;class InputIterator&gt;
<B>multimap</B>(InputIterator first,
          InputIterator last,
          const Compare&amp; comp = Compare()
          const Allocator&amp; alloc = Allocator());</PRE>

<UL>
<P>Constructs a multimap containing values in the range <SAMP>[first, last)</SAMP>.   Creation of the new multimap is only guaranteed to succeed if the iterators <SAMP>first</SAMP> and <SAMP>last</SAMP> return values of type <SAMP>pair&lt;class Key, class T&gt;.</SAMP></P>
</UL>



<PRE><B>multimap</B>(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Creates a new multimap by copying all pairs of <SAMP>key</SAMP> and <SAMP>value</SAMP> from <SAMP>x</SAMP>.</P>
</UL>


<A NAME="Destructors"><H3>Destructors</H3></A>


<PRE><B>~multimap</B>();</PRE>

<UL>
<P>Releases any allocated memory for this multimap.</P>
</UL>


<A NAME="Assignment Operators"><H3>Assignment Operators</H3></A>


<A NAME="Assignment Operatorsoperator=()"></A><PRE>multimap&lt;Key, T, Compare, Allocator&gt;&amp; 
<B>operator=</B>(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Replaces the contents of <SAMP>*this</SAMP> with a copy of the multimap <SAMP>x</SAMP>.</P>
</UL>


<A NAME="Allocators"><H3>Allocators</H3></A>


<A NAME="Allocatorsget_allocator()"></A><PRE>allocator_type 
<B>get_allocator</B>() const;</PRE>

<UL>
<P>Returns a copy of the allocator used by self for storage management.</P>
</UL>


<A NAME="Iterators"><H3>Iterators</H3></A>


<A NAME="Iteratorsbegin()"></A><PRE>iterator 
<B>begin</B>();</PRE>

<UL>
<P>Returns a bidirectional <SAMP>iterator</SAMP> pointing to the first element stored in the multimap. "First" is defined by the multimap's comparison operator, <SAMP>Compare</SAMP>.</P>
</UL>



<PRE>const_iterator 
<B>begin</B>() const;</PRE>

<UL>
<P>Returns a <SAMP>const_iterator</SAMP> pointing to the first element stored in the multimap. "First" is defined by the multimap's comparison operator, <SAMP>Compare</SAMP>.</P>
</UL>



<A NAME="Iteratorsend()"></A><PRE>iterator 
<B>end</B>();</PRE>

<UL>
<P>Returns a bidirectional <SAMP>iterator</SAMP> pointing to the last element stored in the multimap (in other words, the off-the-end value).</P>
</UL>



<PRE>const_iterator 
<B>end</B>() const;</PRE>

<UL>
<P>Returns a <SAMP>const_iterator</SAMP> pointing to the last element stored in the multimap.</P>
</UL>



<A NAME="Iteratorsrbegin()"></A><PRE>reverse_iterator 
<B>rbegin</B>();</PRE>

<UL>
<P>Returns a <SAMP>reverse_iterator</SAMP> pointing to the first element stored in the multimap. "First" is defined by the multimap's comparison operator, <SAMP>Compare</SAMP>.</P>
</UL>



<PRE>const_reverse_iterator 
<B>rbegin</B>() const;</PRE>

<UL>
<P>Returns a <SAMP>const_reverse_iterator</SAMP> pointing to the first element stored in the multimap.</P>
</UL>



<A NAME="Iteratorsrend()"></A><PRE>reverse_iterator 
<B>rend</B>();</PRE>

<UL>
<P>Returns a <SAMP>reverse_iterator</SAMP> pointing to the last element stored in the multimap (in other words, the off-the-end value).</P>
</UL>



<PRE>const_reverse_iterator 
<B>rend</B>() const;</PRE>

<UL>
<P>Returns a <SAMP>const_reverse_iterator</SAMP> pointing to the last element stored in the multimap.</P>
</UL>


<A NAME="Member Functions"><H3>Member Functions</H3></A>


<A NAME="Member Functionsclear()"></A><PRE>void
<B>clear</B>();</PRE>

<UL>
<P>Erases all elements from the self.</P>
</UL>



<A NAME="Member Functionscount()"></A><PRE>size_type 
<B>count</B>(const key_type&amp; x) const;</PRE>

<UL>
<P>Returns the number of elements in the multimap with the key value <SAMP>x</SAMP>.</P>
</UL>



<A NAME="Member Functionsempty()"></A><PRE>bool 
<B>empty</B>() const;</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the multimap is empty, <SAMP>false</SAMP> otherwise.</P>
</UL>



<A NAME="Member Functionsequal_range()"></A><PRE>pair&lt;iterator,iterator&gt; 
<B>equal_range</B>(const key_type&amp; x);
pair&lt;const_iterator,const_iterator&gt; 
<B>equal_range</B>(const key_type&amp; x) const;</PRE>

<UL>
<P>Returns the pair <SAMP>(lower_bound(x), upper_bound(x))</SAMP>.</P>
</UL>



<A NAME="Member Functionserase()"></A><PRE>void
<B>erase</B>(iterator first, iterator last);</PRE>

<UL>
<P>If the iterators <SAMP>first</SAMP> and <SAMP>last</SAMP> point to the same multimap and last is reachable from first, all elements in the range (<SAMP>first, last</SAMP>) are deleted from the multimap. Returns an <SAMP>iterator</SAMP> pointing to the element following the last deleted element or <SAMP>end(),</SAMP> if there were no elements after the deleted range.</P>
</UL>



<PRE>void
<B>erase</B>(iterator position);</PRE>

<UL>
<P>Deletes the multimap element pointed to by the iterator <SAMP>position</SAMP>. Returns an <SAMP>iterator</SAMP> pointing to the element following the deleted element, or <SAMP>end(),</SAMP> if the deleted item was the last one in this list.</P>
</UL>



<PRE>size_type 
<B>erase</B>(const key_type&amp; x);</PRE>

<UL>
<P>Deletes the elements with the key value <SAMP>x</SAMP> from the map, if any exist. Returns the number of deleted elements, or <SAMP>0</SAMP> otherwise. </P>
</UL>



<A NAME="Member Functionsfind()"></A><PRE>iterator 
<B>find</B>(const key_type&amp; x);</PRE>

<UL>
<P>Searches the multimap for a pair with the key value <SAMP>x</SAMP> and returns an <SAMP>iterator</SAMP> to that pair if it is found. If such a pair is not found the value <SAMP>end()</SAMP> is returned.</P>
</UL>



<PRE>const_iterator 
<B>find</B>(const key_type&amp; x) const;</PRE>

<UL>
<P>Same as find above but returns a <SAMP>const_iterator</SAMP>.</P>
</UL>



<A NAME="Member Functionsinsert()"></A><PRE>iterator 
<B>insert</B>(const value_type&amp; x);
iterator 
<B>insert</B>(iterator position, const value_type&amp; x);</PRE>

<UL>
<P><SAMP>x</SAMP> is inserted into the multimap. A position may be supplied as a hint regarding where to do the insertion. If the insertion is done right after <SAMP>position</SAMP>, then it takes amortized constant time. Otherwise it takes <SAMP>O(log N)</SAMP> time.</P>
</UL>



<PRE>template &lt;class InputIterator&gt;
void 
<B>insert</B>(InputIterator first, InputIterator last);</PRE>

<UL>
<P>Copies of each element in the range <SAMP>[first, last)</SAMP> are inserted into the multimap. The iterators <SAMP>first</SAMP> and <SAMP>last</SAMP> must return values of type <SAMP>pair&lt;T1,T2&gt;</SAMP>. This operation takes approximately <SAMP>O(N*log(size()+N))</SAMP> time.</P>
</UL>



<A NAME="Member Functionskey_comp()"></A><PRE>key_compare 
<B>key_comp</B>() const;</PRE>

<UL>
<P>Returns a function object capable of comparing key values using the comparison operation, <SAMP>Compare</SAMP>, of the current multimap.</P>
</UL>



<A NAME="Member Functionslower_bound()"></A><PRE>iterator 
<B>lower_bound</B>(const key_type&amp; x);</PRE>

<UL>
<P>Returns an <SAMP>iterator</SAMP> to the first multimap element whose key is greater than or equal to <SAMP>x</SAMP>. If no such element exists, then <SAMP>end()</SAMP> is returned.</P>
</UL>



<PRE>const_iterator 
<B>lower_bound</B>(const key_type&amp; x) const;</PRE>

<UL>
<P>Same as <SAMP>lower_bound</SAMP> above but returns a <SAMP>const_iterator.</SAMP></P>
</UL>



<A NAME="Member Functionsmax_size()"></A><PRE>size_type 
<B>max_size</B>() const;</PRE>

<UL>
<P>Returns the maximum possible size of the multimap.</P>
</UL>



<A NAME="Member Functionssize()"></A><PRE>size_type 
<B>size</B>() const;</PRE>

<UL>
<P>Returns the number of elements in the multimap.</P>
</UL>



<A NAME="Member Functionsswap()"></A><PRE>void 
<B>swap</B>(multimap&lt;Key, T, Compare, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Swaps the contents of the multimap <SAMP>x</SAMP> with the current multimap, <SAMP>*this</SAMP>.</P>
</UL>



<A NAME="Member Functionsupper_bound()"></A><PRE>iterator
<B>upper_bound</B>(const key_type&amp; x);</PRE>

<UL>
<P>Returns an <SAMP>iterator</SAMP> to the first element whose key is less than or equal to <SAMP>x</SAMP>. If no such element exists, then <SAMP>end()</SAMP> is returned.</P>
</UL>



<PRE>const_iterator 
<B>upper_bound</B>(const key_type&amp; x) const;</PRE>

<UL>
<P>Same as <SAMP>upper_bound</SAMP> above but returns a <SAMP>const_iterator</SAMP>.</P>
</UL>



<A NAME="Member Functionsvalue_comp()"></A><PRE>value_compare 
<B>value_comp</B>() const;</PRE>

<UL>
<P>Returns a function object capable of comparing <SAMP>value_types</SAMP> (<SAMP>key,value</SAMP> pairs) using the comparison operation, <SAMP>Compare</SAMP>, of the current multimap.</P>
</UL>


<A NAME="Non-member Operators"><H3>Non-member Operators</H3></A>


<A NAME="Non-member Operatorsoperator==()"></A><PRE>bool 
<B>operator==</B>(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,
           const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if all elements in <SAMP>x</SAMP> are element-wise equal to all elements in <SAMP>y</SAMP>, using <SAMP>(T::operator==).</SAMP> Otherwise it returns <SAMP>false</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator!=()"></A><PRE>bool 
<B>operator!=</B>(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,
           const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>!(x==y)</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&lt;()"></A><PRE>bool 
<B>operator&lt;</B>(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,
           const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if <SAMP>x</SAMP> is lexicographically less than <SAMP>y</SAMP>. Otherwise, it returns <SAMP>false</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&gt;()"></A><PRE>bool 
<B>operator&gt;</B>(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,
           const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>y &lt; x</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&lt;=()"></A><PRE>bool 
<B>operator&lt;=</B>(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,
           const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>!(y &lt; x)</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&gt;=()"></A><PRE>bool 
<B>operator&gt;=</B>(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,
           const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>!(x &lt; y)</SAMP>.</P>
</UL>


<A NAME="Specialized Algorithms"><H3>Specialized Algorithms</H3></A>


<PRE>template&lt;class Key, class T, class Compare, class Allocator&gt;
void <B>swap</B>(multimap&lt;Key, T, Compare, Allocator&gt;&amp; a,
           multimap&lt;Key, T, Compare, Allocator&gt;&amp; b);</PRE>

<UL>
<P>Swaps the contents of <SAMP>a</SAMP> and <SAMP>b</SAMP>.</P>
</UL>


<A NAME="Example"><H3>Example</H3></A>
<UL>
<PRE>//
// multimap.cpp
//
 #include &lt;string&gt;
 #include &lt;map&gt;
 #include &lt;iostream&gt;
 using namespace std;

 typedef <B>multimap</B>&lt;int, string, less&lt;int&gt; &gt; months_type;

 // Print out a pair
 template &lt;class First, class Second&gt;
 ostream&amp; operator&lt;&lt;(ostream&amp; out, 
                     const pair&lt;First,Second&gt;&amp; p)
 {
   cout &lt;&lt; p.second &lt;&lt; " has " &lt;&lt; p.first &lt;&lt; " days";
   return out;
 }

 // Print out a multimap
 ostream&amp; operator&lt;&lt;(ostream&amp; out, months_type l)
 {
   copy(l.begin(),l.end(), ostream_iterator
             &lt;months_type::value_type,char&gt;(cout,"\n"));
   return out;
 }

 int main(void)
 {
   // create a multimap of months and the number of 
   // days in the month
   months_type months;

   typedef months_type::value_type value_type;
 
   // Put the months in the multimap
   months.insert(value_type(31, string("January")));
   months.insert(value_type(28, string("February")));
   months.insert(value_type(31, string("March")));
   months.insert(value_type(30, string("April")));
   months.insert(value_type(31, string("May")));
   months.insert(value_type(30, string("June")));
   months.insert(value_type(31, string("July")));
   months.insert(value_type(31, string("August")));
   months.insert(value_type(30, string("September")));
   months.insert(value_type(31, string("October")));
   months.insert(value_type(30, string("November")));
   months.insert(value_type(31, string("December")));


   // print out the months
   cout &lt;&lt; "All months of the year" &lt;&lt; endl &lt;&lt; months 
        &lt;&lt; endl;

   // Find the Months with 30 days
   pair&lt;months_type::iterator,months_type::iterator&gt; p = 
          months.equal_range(30);

   // print out the 30 day months 
   cout &lt;&lt; endl &lt;&lt; "Months with 30 days" &lt;&lt; endl;
   copy(p.first,p.second,
        ostream_iterator&lt;months_type::value_type,char&gt;
       (cout,"\n"));
 
   return 0;
 }</PRE>

</UL>
<P><B>Program Output</B></P>
<UL>
<PRE>
All months of the year
February has 28 days
April has 30 days
June has 30 days
September has 30 days
November has 30 days
January has 31 days
March has 31 days
May has 31 days
July has 31 days 
August has 31 days
October has 31 days
December has 31 days

Months with 30 days
April has 30 days
June has 30 days
September has 30 days
November has 30 days</PRE>

</UL>

<A NAME="Warnings"><H3>Warnings</H3></A>
<P>Member function templates are used in all containers included in the Standard Template Library. An example of this feature is the constructor for <B><I>multimap&lt;Key,T,Compare,Allocator&gt;</I></B> that takes two templatized iterators:</P>
<UL>
<PRE>template &lt;class InputIterator&gt;
 multimap (InputIterator, InputIterator, 
           const Compare&amp; = Compare(),
           const Allocator&amp; = Allocator());</PRE>

</UL>
<P><B><I>multimap</I></B> also has an <SAMP>insert</SAMP> function of this type. These functions, when not restricted by compiler limitations, allow you to use any type of input iterator as arguments. For compilers that do not support this feature, substitute functions allow you to use an iterator obtained from the same type of container as the one you are constructing (or calling a member function on), or you can use a pointer to the type of element you have in the container.</P>
<P>For example, if your compiler does not support member function templates, you can construct a multimap in the following two ways: </P>
<UL>
<PRE>multimap&lt;int,int&gt;::value_type intarray[10];
multimap&lt;int,int&gt; first_map(intarry, intarray + 10);
multimap&lt;int,int&gt; second_multimap(first_multimap.begin(),
                  first_multimap.end());</PRE>

</UL>
<P>but not this way:</P>
<UL>
<PRE>multimap&lt;long,long&gt;
 long_multimap(first_multimap.begin(),first_multimap.end());</PRE>

</UL>
<P>since the <SAMP>long_multimap</SAMP> and <SAMP>first_multimap</SAMP> are not the same type.</P>
<P>Also, many compilers do not support default template arguments. If your compiler is one of these you always need to supply the <SAMP>Compare</SAMP> template argument and the <SAMP>Allocator</SAMP> template argument. For instance, you have to write:</P>
<P><SAMP>multimap&lt;int, int, less&lt;int&gt;, allocator&lt;int&gt; &gt;</SAMP></P>
<P>instead of:</P>
<P><SAMP>multimap&lt;int, int&gt;</SAMP></P>
<P>If your compiler does not support namespaces, then you do not need the using declaration for <SAMP>std</SAMP>.</P>

<A NAME="See Also"><H3>See Also</H3></A>
<P><B><I><A HREF="all_7029.htm">allocator</A></I></B>, <B><I><A HREF="Con_2487.htm">Containers</A></I></B>, <B><I><A HREF="Ite_5295.htm">Iterators</A></I></B>, <B><I><A HREF="map_8018.htm">map</A></I></B></P>


<BR>
<HR>
<A HREF="mon_8228.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="mul_0796.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<BR>&copy;Copyright 1999, Rogue Wave Software, Inc.<BR>Send <A HREF="mailto:onlinedocs@roguewave.com">mail</A> to report errors or comment on the documentation.
<BR>
OEM Release</BODY></HTML>
