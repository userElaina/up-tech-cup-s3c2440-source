<HTML><HEAD><TITLE>slice_array</TITLE></HEAD><BODY BGCOLOR=#FFFFFF>
<IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0><BR>
<A HREF="sli_0626.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="sma_5227.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><BR>

<H2>slice_array</H2>
<PRE><HR>Valarray helpers
<HR></PRE>
<UL>
<LI><A HREF="#Summary">Summary</A></LI>
<LI><A HREF="#memindex">Data Type and Member Function Indexes</A></LI>
<LI><A HREF="#Synopsis">Synopsis</A></LI>
<LI><A HREF="#Description">Description</A></LI>
<LI><A HREF="#Interface">Interface</A></LI>
<LI><A HREF="#Constructors">Constructors</A></LI>
<LI><A HREF="#Assignment Operators">Assignment Operators</A></LI>
<LI><A HREF="#Computed Assignment Operators">Computed Assignment Operators</A></LI>
<LI><A HREF="#Member Functions">Member Functions</A></LI>
<LI><A HREF="#Example">Example</A></LI>
<LI><A HREF="#Warnings">Warnings</A></LI>
<LI><A HREF="#See Also">See Also</A></LI>

</UL>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A numeric array class for representing a BLAS-like <B><I><A HREF="sli_0626.htm">slice</A></I></B> from a <B><I><A HREF="val_6244.htm">valarray</A></I></B>.</P>
<A NAME="memindex"><H3>Data Type and Member Function Indexes<BR>(exclusive of constructors and destructors)</H3></A>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Member Functions</B></TD></TR><TR><TD VALIGN=top><A HREF="#Computed Assignment Operatorsoperator%=()">operator%=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator&amp;=()">operator&amp;=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator&gt;&gt;=()">operator&gt;&gt;=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator&lt;&lt;=()">operator&lt;&lt;=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator*=()">operator*=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator+=()">operator+=()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Computed Assignment Operatorsoperator-=()">operator-=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator/=()">operator/=()</A><BR>
 <A HREF="#Assignment Operatorsoperator=()">operator=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator^=()">operator^=()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>
<PRE>#include &lt;valarray&gt;
template &lt;class T&gt;
class <B>slice_array</B> ;</PRE>

</PRE>

<A NAME="Description"><H3>Description</H3></A>
<P><B><I>slice_array&lt;T&gt;</I></B> gives a slice view into a <B><I><A HREF="val_6244.htm">valarray</A></I></B>. <B><I>Slice_array</I></B>s are only produced by applying the slice subscript operator to a <B><I>valarray</I></B>. The elements in a <B><I>slice_array</I></B> are references to selected elements in the <B><I>valarray</I></B> (so changing an element in the <B><I>slice_array</I></B> really changes the corresponding element in the <B><I>valarray</I></B>). A <B><I>slice_array</I></B> does not itself hold any distinct elements. The template cannot be instantiated directly since all its constructors are private. However, you can easily copy a <B><I>slice_array</I></B> to a <B><I>valarray</I></B> using either the <B><I>valarray</I></B> copy constructor or the assignment operator. Reference semantics are lost at that point. </P>

<A NAME="Interface"><H3>Interface</H3></A>
<PRE>
<PRE>template &lt;class T&gt; class slice_array {
public:

  // types
  typedef T value_type;

  // destructor
  ~slice_array();

  // public assignment
  void operator= (const valarray&lt;T&gt;&amp; array) const;
  // computed assignment
  void operator*= (const valarray&lt;T&gt;&amp; array) const;
  void operator/= (const valarray&lt;T&gt;&amp; array) const;
  void operator%= (const valarray&lt;T&gt;&amp; array) const;
  void operator+= (const valarray&lt;T&gt;&amp; array) const;
  void operator-= (const valarray&lt;T&gt;&amp; array) const;
  void operator^= (const valarray&lt;T&gt;&amp; array) const;
  void operator&amp;= (const valarray&lt;T&gt;&amp; array) const;
  void operator|= (const valarray&lt;T&gt;&amp; array) const;
  void operator&lt;&lt;= (const valarray&lt;T&gt;&amp; array) const;
  void operator&gt;&gt;= (const valarray&lt;T&gt;&amp; array) const;
 
  // other
  void operator= (const T&amp;);  

private:
  // constructors
  slice_array();
  slice_array(const slice_array&lt;T&gt;&amp;);
  // operator =
  slice_array&lt;T&gt;&amp; operator= (const slice_array&lt;T&gt;&amp; array);
};</PRE>

</PRE>

<A NAME="Constructors"><H3>Constructors</H3></A>


<PRE><B>slice_array</B>();
<B>slice_array</B>(const slice_array&amp;);</PRE>

<UL>
<P>All <B><I>slice_array</I></B> constructors are private and cannot be called directly. This prevents copy construction of <B><I>slice_array</I></B>s.</P>
</UL>


<A NAME="Assignment Operators"><H3>Assignment Operators</H3></A>


<A NAME="Assignment Operatorsoperator=()"></A><PRE>void <B>operator=</B>(const valarray&lt;T&gt;&amp; x) const;</PRE>

<UL>
<P>Assigns values from <SAMP>x</SAMP> to the selected elements of the <B><I><A HREF="val_6244.htm">valarray</A></I></B> that self refers to. Remember that a <B><I>slice_array</I></B> never holds any elements itself, it simply refers to selected elements in the <B><I>valarray</I></B> used to generate it.</P>
</UL>



<PRE>slice_array&lt;T&gt;&amp; 
<B>operator=</B>(const slice-_array&lt;T&gt;&amp; x);</PRE>

<UL>
<P>Private assignment operator. Cannot be called directly, thus preventing assignment between <B><I>slice_array</I></B>s.</P>
</UL>


<A NAME="Computed Assignment Operators"><H3>Computed Assignment Operators</H3></A>


<A NAME="Computed Assignment Operatorsoperator*=()"></A><PRE>void <B>operator*=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator/=()"></A>void <B>operator/=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator%=()"></A>void <B>operator%=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator+=()"></A>void <B>operator+=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator-=()"></A>void <B>operator-=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator^=()"></A>void <B>operator^=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator&amp;=()"></A>void <B>operator&amp;=</B>(const valarray&lt;T&gt;&amp; val) const;
void <B>operator|=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator&lt;&lt;=()"></A>void <B>operator&lt;&lt;=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator&gt;&gt;=()"></A>void <B>operator&gt;&gt;=</B>(const valarray&lt;T&gt;&amp; val) const;</PRE>

<UL>
<P>Applies the indicated operation using elements from <SAMP>val</SAMP> to the selected elements of the <B><I><A HREF="val_6244.htm">valarray</A></I></B> that self refers to. Remember that a <B><I>slice_array</I></B> never holds any elements itself; it simply refers to selected elements in the <B><I>valarray</I></B> used to generate it.</P>
</UL>


<A NAME="Member Functions"><H3>Member Functions</H3></A>


<PRE>void <B>operator=</B> (const T&amp; x);</PRE>

<UL>
<P>Assigns <SAMP>x</SAMP> to the selected elements of the <B><I><A HREF="val_6244.htm">valarray</A></I></B> that self refers to. </P>
</UL>


<A NAME="Example"><H3>Example</H3></A>
<UL>
<PRE>//
// slice_array.cpp
//
#include "valarray.h"  // Contains a valarray 
                       // stream inserter
using namespace std;

int main(void)
{
  int ibuf[10] = {0,1,2,3,4,5,6,7,8,9};
  int ibuf2[5] = {1,3,5,7,9};

  // create a valarray of ints
  valarray&lt;int&gt;         vi(ibuf,10);
  valarray&lt;int&gt;         vi2(ibuf2,5);

  // print it out
  cout &lt;&lt; vi &lt;&lt; endl &lt;&lt; vi2 &lt;&lt; endl;

  // Get a slice and assign that slice to another array
  slice_array&lt;int&gt; sl = vi[slice(1,5,2)];
  valarray&lt;int&gt; vi3 = sl;

  // print out the slice
  cout &lt;&lt; vi3 &lt;&lt; endl;
  
  // Add slice from vi2 to slice of vi1
  sl += vi2;

  // print out vi1 again
  cout &lt;&lt; vi &lt;&lt; endl;

  return 0;
}</PRE>

</UL>
<P><B>Program Output</B></P>
<UL>
<PRE> 
[0,1,2,3,4,5,6,7,8,9]
[1,3,5,7,9]
[1,3,5,7,9]
[0,2,2,6,4,10,6,14,8,18]</PRE>

</UL>

<A NAME="Warnings"><H3>Warnings</H3></A>
<P>If your compiler does not support namespaces, then you do not need the using declaration for <SAMP>std</SAMP>.</P>

<A NAME="See Also"><H3>See Also</H3></A>
<P><B><I><A HREF="val_6244.htm">valarray</A></I></B>, <B><I><A HREF="sli_0626.htm">slice</A></I></B>, <B><I><A HREF="gsl_4121.htm">gslice</A></I></B>, <B><I><A HREF="gsl_1439.htm">gslice_array</A></I></B>, <B><I><A HREF="mas_2579.htm">mask_array</A></I></B>, <B><I><A HREF="ind_9304.htm">indirect_array</A></I></B></P>


<BR>
<HR>
<A HREF="sli_0626.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="sma_5227.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<BR>&copy;Copyright 1999, Rogue Wave Software, Inc.<BR>Send <A HREF="mailto:onlinedocs@roguewave.com">mail</A> to report errors or comment on the documentation.
<BR>
OEM Release</BODY></HTML>
