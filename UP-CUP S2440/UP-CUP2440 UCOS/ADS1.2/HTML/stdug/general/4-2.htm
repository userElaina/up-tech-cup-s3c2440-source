<HTML><HEAD><TITLE>4.2 Selecting a Container</TITLE></HEAD>
<BODY BGCOLOR=#FFFFFF>
<A HREF="../index.htm"><IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0></A><BR>
<A HREF="4-1.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="4-3.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<H2>4.2 Selecting a Container</H2>
<A NAME="idx57"><!></A>
<P>Given ten Standard C++ Library containers, which type of container is best suited for solving a particular problem? Sometimes the answer is obvious, but other times there can be several viable alternatives. For the difficult cases, you may want to compare the actual execution timings using different containers to determine the best alternative. For most other cases, these simple criteria can help you decide:</P>
<TABLE BORDER=0 CELLPADDING=3 CELLSPACING=3>

<tr><td valign=top>
<B><I>How are values going to be accessed?</I></B><BR>
<td valign=top>
If random access is important, then a <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B> or a <B><I><A HREF="../../stdref/deq_4164.htm">deque</A></I></B> should be used. If sequential access is sufficient, then one of the other structures may be suitable.<BR>

<tr><td valign=top>
<B><I>Is the order in which values are maintained in the collection important?</I></B><BR>
<td valign=top>
There are a number of different ways values can be sequenced. If a strict ordering is important throughout the life of the container, then the <B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B> data structure is an obvious choice, as insertions into a set are automatically placed in order. <BR>
If this ordering is important only at one point--for example, at the end of a long series of insertions--then it might be easier to place the values into a <B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B> or <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B>, and sort the resulting structure at the appropriate time. <BR>
If the order that values are held in the structure is related to the order of insertion, then a <B><I><A HREF="../../stdref/sta_9602.htm">stack</A></I></B>, <B><I><A HREF="../../stdref/que_0953.htm">queue</A></I></B>, or <B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B> may be the best choice.<BR>

<tr><td valign=top>
<B><I>Will the size of the structure vary widely over the course of execution?</I></B><BR>
<td valign=top>
If so, a <B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B> or <B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B> might be the best choice. A <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B> or <B><I><A HREF="../../stdref/deq_4164.htm">deque</A></I></B> will continue to maintain a large buffer even after elements have been removed from the collection. Conversely, if the size of the collection remains relatively fixed, than a vector or deque will use less memory than a list or set holding the same number of elements.<BR>

<tr><td valign=top>
<B><I>Is it possible to estimate the size of the collection?</I></B><BR>
<td valign=top>
The <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B> data structure provides a way to pre-allocate a block of memory of a given size, using the <SAMP>reserve()</SAMP> member function. This ability is not provided by the other containers.<BR>

<tr><td valign=top>
<B><I>Is testing to see whether a value is contained in the collection a frequent operation?</I></B><BR>
<td valign=top>
If so, then the <B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B> or <B><I><A HREF="../../stdref/map_8018.htm">map</A></I></B> containers would be a good choice. Testing to see whether a value is contained in a set or map can be performed in a very small number of steps, logarithmic in the size of the container, whereas testing to see if a value is contained in one of the other types of collections might require comparing the value against every element being stored by the container.<BR>

<tr><td valign=top>
<B><I>Is the collection indexed? That is, can the collection be viewed as a series of key/value pairs?</I></B><BR>
<td valign=top>
If the keys are integers between 0 and some upper limit, a <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B> or <B><I><A HREF="../../stdref/deq_4164.htm">deque</A></I></B> should be used. On the other hand, if the key values are some other ordered datatype--like character, string, or user-defined type--the <B><I><A HREF="../../stdref/map_8018.htm">map</A></I></B> container can be used.<BR>

<tr><td valign=top>
<B><I>Can values be related to each other?</I></B><BR>
<td valign=top>
All values stored in any container provided by the Standard C++ Library must be able to test for equality against another similar value, but not all need to recognize the relational less-than operator. However, if values cannot be ordered using the relational less-than operator, they cannot be stored in a <B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B> or a <B><I><A HREF="../../stdref/map_8018.htm">map</A></I></B>.<BR>

<tr><td valign=top>
<B><I>Is finding and removing the largest value from the collection a frequent operation?</I></B><BR>
<td valign=top>
If the answer is yes, the <B><I><A HREF="../../stdref/pri_2327.htm">priority_queue</A></I></B> is the best data structure to use.<BR>

<tr><td valign=top>
<B><I>At what positions are values inserted into or removed from the structure?</I></B><BR>
<td valign=top>
If values are inserted into or removed from the middle, then a <B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B> is the best choice. If values are inserted only at the beginning, a <B><I><A HREF="../../stdref/deq_4164.htm">deque</A></I></B> or a <B><I>list</I></B> is the preferred choice. If values are inserted or removed only at the end, a <B><I><A HREF="../../stdref/sta_9602.htm">stack</A></I></B> or <B><I><A HREF="../../stdref/que_0953.htm">queue</A></I></B> may be a logical choice.<BR>

<tr><td valign=top>
<B><I>Is the merging of two or more sequences into one a frequent operation?</I></B><BR>
<td valign=top>
If so, a <B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B> or a <B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B> would seem to be the best choice, depending whether the collection is maintained in order. Merging two sets is a very efficient operation. If the collections are not ordered, but the efficient <SAMP>splice()</SAMP> member function from class list can be used, then the list datatype is to be preferred, since this operation is not provided in the other containers.<BR>


</TABLE>


</P>

<HR>
<A HREF="4-1.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="4-3.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><P>OEM Edition, &copy;Copyright 1999, Rogue Wave Software, Inc.<BR><A HREF="contact.htm">Contact</A> Rogue Wave about documentation or support issues.</P>
</BODY></HTML>
