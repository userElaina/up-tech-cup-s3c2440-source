<HTML><HEAD><TITLE>2.2 Varieties of Iterators</TITLE></HEAD>
<BODY BGCOLOR=#FFFFFF>
<A HREF="../index.htm"><IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0></A><BR>
<A HREF="2-1.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="2-3.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<H2>2.2 Varieties of Iterators</H2>
<A NAME="idx13"><!></A>
<P>As shown in <A HREF="#Table 3">Table 3</A>, there are five basic forms of iterators used in the Standard C++ Library:</P>
<TABLE BORDER CELLPADDING=3 CELLSPACING=3>
<H4><A NAME="Table 3">Table 3 -- Iterator forms in the Standard C++ Library</A> </H4><tr><td valign=top><B><B>Iterator form</B></B><td valign=top><B><B>Description</B></B>&nbsp;
<tr><td valign=top>
input iterator <BR>
<td valign=top>
Read only, forward moving <BR>

<tr><td valign=top>
output iterator <BR>
<td valign=top>
Write only, forward moving <BR>

<tr><td valign=top>
forward iterator<BR>
<td valign=top>
Both read and write, forward moving <BR>

<tr><td valign=top>
bidirectional iterator <BR>
<td valign=top>
Read and write, forward and backward moving <BR>

<tr><td valign=top>
random access iterator<BR>
<td valign=top>
Read and write, random access <BR>


</TABLE>


</P>
<A NAME="idx14"><!></A>
<P>Iterator categories are hierarchical. <I>Forward iterators</I> can be used wherever input or output iterators are required, <I>bidirectional iterators</I> can be used in place of forward iterators, and <I>random access iterators</I> can be used in situations requiring bidirectionality. </P>
<A NAME="idx15"><!></A>
<P>A second characteristic of iterators is whether or not they can be used to modify the values held by their associated container. A <I>constant iterator</I> is one that can be used for access only, and cannot be used for modification. <I>Output iterators</I> are never constant, and <I>input</I> iterators always are. Other iterators may or may not be constant, depending upon how they are created. There are both constant and non-constant bidirectional iterators, both constant and non-constant random access iterators, and so on.</P>
<P><A HREF="#Table 4">Table 4</A> summarizes specific ways that various categories of iterators are generated by the containers in the Standard C++ Library.</P>
<TABLE BORDER CELLPADDING=3 CELLSPACING=3>
<H4><A NAME="Table 4">Table 4 -- Iterators generated in the Standard C++ Library</A> </H4><tr><td valign=top><B>Iterator form</B><td valign=top> <B>Produced by</B>
<A NAME="idx16"><!></A>
<tr><td valign=top>
input iterator<BR>
<td valign=top>
<SAMP>istream_iterator</SAMP><BR>

<A NAME="idx17"><!></A>
<tr><td valign=top>
output iterator <BR>
<td valign=top>
<SAMP>ostream_iterator</SAMP>  <BR>
<SAMP>inserter</SAMP>   <BR>
<SAMP>front_inserter</SAMP>   <BR>
<SAMP>back_inserter</SAMP><BR>

<A NAME="idx18"><!></A>
<tr><td valign=top>
bidirectional iterator <BR>
<td valign=top>
<B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B>   <BR>
<B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B> and <B><I><A HREF="../../stdref/mul_0958.htm">multiset</A></I></B>   <BR>
<B><I><A HREF="../../stdref/map_8018.htm">map</A></I></B> and <B><I><A HREF="../../stdref/mul_8396.htm">multimap</A></I></B><BR>

<A NAME="idx19"><!></A>
<tr><td valign=top>
random access iterator <BR>
<td valign=top>
ordinary pointers    <BR>
<B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B>   <BR>
<B><I><A HREF="../../stdref/deq_4164.htm">deque</A></I></B><BR>


</TABLE>


</P>
<P>In the following sections we describe the capabilities and construction of each form of iterator.</P>

<A NAME="221"><H3>2.2.1 Input Iterators</H3></A>
<A NAME="idx20"><!></A>
<P>Input iterators are the simplest form of iterator. To understand their capabilities, consider an example program: </P>
<UL>
<PRE>
template &lt;class InputIterator, class T&gt;
<SAMP>InputIterator</SAMP> 
   <SAMP>find (InputIterator first, InputIterator last, const T&amp; value)</SAMP>
<SAMP>{</SAMP>
   <SAMP>while (first != last &amp;&amp; *first != value)</SAMP> 
      <SAMP>++first;</SAMP>
   <SAMP>return first;</SAMP>
<SAMP>}</SAMP></PRE>
</UL>
<P>In this program, the <SAMP>find()</SAMP> generic algorithm (<A HREF="13-3.htm#1331">Section 13.3.1</A>) performs a simple linear search, looking for a specific value being held within a container. The contents of the container are described using two iterators, <SAMP>first</SAMP> and <SAMP>last</SAMP>. While <SAMP>first</SAMP> is not equal to <SAMP>last</SAMP>, the element denoted by <SAMP>first</SAMP> is compared to the test value.  If this element is equal to the test value, the iterator, which now denotes the located element, is returned.  If it is not equal, the <SAMP>first</SAMP> iterator is incremented and the loop cycles once more.  If the entire region of memory is examined without finding the desired value, then the algorithm returns the end-of-range iterator.</P>
<P>This algorithm illustrates three features of an <I>input iterator</I>:</P>
<UL>
<LI><P>An input iterator can be compared for equality to another iterator.  They are equal when they point to the same position, and not equal otherwise.</P>
</LI>
<LI><P>An input iterator can be dereferenced, using the operator <SAMP>*</SAMP> to obtain the value being denoted by the iterator.</P>
</LI>
<LI><P>An input iterator can be incremented, so that it refers to the next element in sequence, using the operator <SAMP>++</SAMP>.</P>
</LI>
</UL>
<P>Notice that these features can all be provided with new meanings in a C++ program, since the behavior of the given functions can all be modified by overloading the appropriate operators.  Because of this overloading, iterators are possible.  </P>

<A NAME="2211"><H4>2.2.1.1 Kinds of Input Iterators</H4></A>
<A NAME="idx21"><!></A>
<P>There are three main kinds of input iterators: ordinary pointers, container iterators, and input streams iterators.</P>
<A NAME="idx22"><!></A>
<P><B>Ordinary pointers</B>. Ordinary pointers can be used as input iterators. In fact, since we can subscript and add to ordinary pointers, they are random access values, and thus can be used either as input or output iterators. The end-of-range pointer describes the end of a contiguous region of memory, and the dereference and increment operators have their conventional meanings. For example, the following searches for the value 7 in an array of integers:</P>
<UL>
<PRE>
int data[100];
   ...
int * where = find(data, data+100, 7);</PRE>
</UL>
<P>Note that constant pointers, which do not permit the underlying array to be modified, can be created by simply placing the keyword <SAMP>const</SAMP> in a declaration:</P>
<UL>
<PRE>
const int * first = data;
const int * last = data + 100;
   // can't modify location returned by the following
const int * where = find(first, last, 7);</PRE>
</UL>
<P>Because ordinary pointers have the same functionality as random access iterators, most of the generic algorithms in the Standard C++ Library can be used with conventional C++ arrays, as well as with the containers provided by the Standard C++ Library.</P>
<A NAME="idx23"><!></A>
<P><B>Container iterators</B>. All of the iterators constructed for the various containers provided by the Standard C++ Library are at <I>least</I> as general as input iterators. The iterator for the first element in a collection is always constructed by the member function <SAMP>begin()</SAMP>, while the iterator that denotes the past-the-end location is generated by the member function <SAMP>end()</SAMP>. For example, the following iterator searches for the value 7 in a list of integers:</P>
<UL>
<PRE>
list&lt;int&gt;::iterator where = find(aList.begin(), aList.end(), 7);</PRE>
</UL>
<P>Each container that supports iterators provides a type with the name <SAMP>iterator</SAMP> within the class declaration. Using this type, iterators can uniformly be declared in the fashion shown. If the container being accessed is constant, or if the description <SAMP>const_iterator</SAMP> is used, then the iterator is a constant iterator.</P>
<A NAME="idx24"><!></A>
<P><B>Input stream iterators</B>. The Standard C++ Library provides a mechanism to operate on an input stream using an input iterator. This ability is provided by the class <SAMP>istream_iterator</SAMP>, described in more detail in <A HREF="2-3.htm#231">Section 2.3.1</A>.</P>

<A NAME="222"><H3>2.2.2 Output Iterators</H3></A>
<A NAME="idx25"><!></A>
<P>An <I>output iterator</I> has the opposite function of an input iterator. Output iterators can be used to assign values in a sequence, but cannot be used to access values. For example, we can use an output iterator in a generic algorithm that copies values from one sequence into another:</P>
<UL>
<PRE>
template &lt;class InputIterator, class OutputIterator&gt;
OutputIterator copy
   (InputIterator first, InputIterator last, OutputIterator result) 
{
    while (first != last) 
      *result++ = *first++;
    return result;
}</PRE>
</UL>
<P>A number of the generic algorithms manipulate two parallel sequences. Frequently the second sequence is described using only a beginning iterator, rather than an iterator pair. It is assumed, but not checked, that the second sequence has at least as many elements as the first.</P>
<P>In the algorithm shown here, two ranges are being manipulated: the range of source values specified by a pair of input iterators, and the destination range. The latter, however, is specified by only a single argument. It is assumed that the destination is large enough to include all values, and errors will ensue if this is not the case.</P>
<P>As illustrated by this algorithm, an output iterator can modify the element to which it points by being used as the target for an assignment. Output iterators can use the dereference operator only in this fashion; they cannot be used to return or to access the elements they denote. </P>
<P>As we noted earlier, ordinary pointers, like all iterators constructed by containers in the Standard C++ Library, can be used as output iterators. (Ordinary pointers are random access iterators, which are a superset of output iterators.) For example, in this code fragment elements from an ordinary C-style array are copied into a Standard C++ Library vector:</P>
<UL>
<PRE>
int data[100];
vector&lt;int&gt; newdata(100);
   ...
copy (data, data+100, newdata.begin());</PRE>
</UL>
<P>Just as the <SAMP>istream_iterator</SAMP> provides a way to operate on an input stream using the input iterator mechanism, the Standard C++ Library provides a datatype, <SAMP>ostream_iterator</SAMP>, that permits values to be written to an output stream in an iterator-like fashion (<A HREF="2-3.htm#232">Section 2.3.2</A>).</P>
<P>Yet another form of output iterator is an <I>insert iterator</I> (<A HREF="2-4.htm">Section 2.4</A>). An insert iterator changes the output iterator operations of dereferencing/assignment and increment into insertions into a container. This permits operations such as <SAMP>copy()</SAMP> to be used with variable length containers, such as <B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B>s and <B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B>s.</P>

<A NAME="223"><H3>2.2.3 Forward Iterators</H3></A>
<A NAME="idx26"><!></A>
<P>A <I>forward iterator</I> combines the features of an input iterator and an output iterator. It permits values to be both accessed and modified. One function that uses forward iterators is the <SAMP>replace()</SAMP> generic algorithm, which replaces occurrences of specific values with other values. This algorithm is written as follows:</P>
<UL>
<PRE>
template &lt;class ForwardIterator, class T&gt;
void 
   replace (ForwardIterator first, ForwardIterator last, 
            const T&amp; old_value, const T&amp; new_value)
{
    while (first != last) 
    {
    if (*first == old_value) 
        *first = new_value;
        ++first;
    }
}</PRE>
</UL>
<P>Ordinary pointers, like all iterators produced by containers in the Standard C++ Library, can be used as forward iterators. For example, in the following code instances of the value 7 are replaced with the value 11 in a vector of integers:</P>
<UL>
<PRE>
replace (aVec.begin(), aVec.end(), 7, 11);</PRE>
</UL>

<A NAME="224"><H3>2.2.4 Bidirectional Iterators</H3></A>
<A NAME="idx27"><!></A>
<P><I>Bidirectional iterators</I> are similar to forward iterators, except that bidirectional iterators support the decrement operator  <SAMP>--</SAMP>, permitting movement in either a forward or a backward direction through the elements of a container. For example, we can use bidirectional iterators in a function that reverses the values of a container, placing the results into a new container:</P>
<UL>
<PRE>
template &lt;class BidirectionalIterator, class OutputIterator&gt;
OutputIterator 
   reverse_copy (BidirectionalIterator first,
                 BidirectionalIterator last,
                 OutputIterator result) 
{
    while (first != last) 
    *result++ = *--last;
    return result;
}</PRE>
</UL>
<P>As always, the value initially denoted by the <SAMP>last</SAMP> argument is not considered part of the collection.</P>
<A NAME="idx28"><!></A>
<P>The <SAMP>reverse_copy()</SAMP> function could be used, for example, to reverse the values of a linked list, and place the result into a vector:</P>
<UL>
<PRE>
list&lt;int&gt; aList;
 ....
vector&lt;int&gt; aVec (aList.size());
reverse_copy (aList.begin(), aList.end(), aVec.begin() );</PRE>
</UL>

<A NAME="225"><H3>2.2.5 Random Access Iterators</H3></A>
<A NAME="idx29"><!></A>
<P>Some algorithms require more functionality than simply accessing values in either a forward or backward direction. Random access iterators permit values to be accessed by subscript, subtracted one from another (to yield the number of elements between their respective values), or modified by arithmetic operations, all in a manner similar to conventional pointers.</P>
<P>With conventional pointers, arithmetic operations can be related to the underlying memory; that is, <SAMP>x+10</SAMP> is the memory ten elements after the beginning of <SAMP>x</SAMP>. With iterators the logical meaning is preserved (<SAMP>x+10</SAMP> is the tenth element after <SAMP>x</SAMP>), however different the physical addresses being described.</P>
<P>Algorithms that use random access iterators include generic operations like sorting and binary search. For example, the following algorithm randomly shuffles the elements of a container. This is similar to, although simpler than, the function <SAMP>random_shuffle()</SAMP> provided by the Standard C++ Library.</P>
<UL>
<PRE>
template &lt;class RandomAccessIterator&gt;
void
   mixup (RandomAccessIterator first, RandomAccessIterator last)
{
   while (first &lt; last) 
   {
      iter_swap(first, first + randomInteger(last - first));
      ++first;
   }
}</PRE>
</UL>
<BLOCKQUOTE><HR>
<B>NOTE: The function randomInteger described here appears in a number of the example programs presented in later sections.
</B><HR></BLOCKQUOTE>
<A NAME="idx30"><!></A>
<P>The program will cycle as long as <SAMP>first</SAMP> denotes a position that occurs earlier in the sequence than the one denoted by <SAMP>last</SAMP>. Only random access iterators can be compared using relational operators; all other iterators can be compared only for equality or inequality. On each cycle through the loop, the expression <br><SAMP>last - first</SAMP> yields the number of elements between the two limits. The function <SAMP>randomInteger()</SAMP> is assumed to generate a random number between 0 and the argument. Using the standard random number generator, this function could be written as follows:</P>
<UL>
<PRE>
unsigned int randomInteger (unsigned int n)
   // return random integer greater than
   // or equal to 0 and less than n
{
   return rand() % n;
}</PRE>
</UL>
<P>This random value is added to the iterator <SAMP>first</SAMP>, resulting in an iterator to a randomly selected value in the container. This value is then swapped with the element denoted by the iterator <SAMP>first</SAMP>.</P>

<A NAME="226"><H3>2.2.6 Reverse Iterators</H3></A>
<A NAME="idx31"><!></A>
<P>An iterator naturally imposes an order on an underlying container of values. For a <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B> or a <B><I><A HREF="../../stdref/map_8018.htm">map</A></I></B>, the order is imposed by increasing index values; for a <B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B>, by the increasing order of the elements held in the container. For a <B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B>, the order is explicitly derived from the way values are inserted.</P>
<P>A <I>reverse iterator</I> yields values in exactly the reverse order of values given by the standard iterators. For a vector or a list, a reverse iterator generates the last element first, and the first element last. For a set it generates the largest element first, and the smallest element last. Strictly speaking, reverse iterators do not constitute a new category of iterator, but an adaptation of another iterator type. Consequently, we have reverse bidirectional iterators and reverse random access iterators. Any bidirectional or random access iterator can be adapted by the <SAMP>reverse_iterator</SAMP> template.</P>
<P>The <B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B>, <B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B>, and <B><I><A HREF="../../stdref/map_8018.htm">map</A></I></B> datatypes provide a pair of member functions that produce reverse bidirectional iterators. The functions <SAMP>rbegin()</SAMP> and <SAMP>rend()</SAMP> generate iterators that cycle through the underlying container in reverse order. Increments to such iterators move backward, and decrements move forward through the sequence.</P>
<P>Similarly, the <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B> and <B><I><A HREF="../../stdref/deq_4164.htm">deque</A></I></B> datatypes provide functions, also named <SAMP>rbegin()</SAMP> and <SAMP>rend()</SAMP>, that produce reverse random access iterators. Subscript and addition operators, as well as increments to such iterators, move backward within the sequence.</P>

<HR>
<A HREF="2-1.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="2-3.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><P>OEM Edition, &copy;Copyright 1999, Rogue Wave Software, Inc.<BR><A HREF="contact.htm">Contact</A> Rogue Wave about documentation or support issues.</P>
</BODY></HTML>
