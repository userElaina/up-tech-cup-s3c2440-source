<HTML><HEAD><TITLE>multiset</TITLE></HEAD><BODY BGCOLOR=#FFFFFF>
<IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0><BR>
<A HREF="mul_0796.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="neg_4682.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><BR>

<H2>multiset</H2>
<PRE><HR>Container Class
<HR></PRE>
<UL>
<LI><A HREF="#Summary">Summary</A></LI>
<LI><A HREF="#memindex">Data Type and Member Function Indexes</A></LI>
<LI><A HREF="#Synopsis">Synopsis</A></LI>
<LI><A HREF="#Description">Description</A></LI>
<LI><A HREF="#Interface">Interface</A></LI>
<LI><A HREF="#Constructors">Constructors</A></LI>
<LI><A HREF="#Destructors">Destructors</A></LI>
<LI><A HREF="#Assignment Operators">Assignment Operators</A></LI>
<LI><A HREF="#Allocators">Allocators</A></LI>
<LI><A HREF="#Iterators">Iterators</A></LI>
<LI><A HREF="#Member Functions">Member Functions</A></LI>
<LI><A HREF="#Non-member Operators">Non-member Operators</A></LI>
<LI><A HREF="#Specialized Algorithms">Specialized Algorithms</A></LI>
<LI><A HREF="#Example">Example</A></LI>
<LI><A HREF="#Warnings">Warnings</A></LI>
<LI><A HREF="#See Also">See Also</A></LI>

</UL>
<A NAME="Summary"><H3>Summary</H3></A>
<P>An associative container that allows fast access to stored key values. Storage of duplicate keys is allowed. A <B><I>multiset</I></B> supports bidirectional iterators.</P>
<A NAME="memindex"><H3>Data Type and Member Function Indexes<BR>(exclusive of constructors and destructors)</H3></A>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Member Functions</B></TD></TR><TR><TD VALIGN=top><A HREF="#Iteratorsbegin()">begin()</A><BR>
 <A HREF="#Member Functionsclear()">clear()</A><BR>
 <A HREF="#Member Functionscount()">count()</A><BR>
 <A HREF="#Member Functionsempty()">empty()</A><BR>
 <A HREF="#Iteratorsend()">end()</A><BR>
 <A HREF="#Member Functionsequal_range()">equal_range()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Functionserase()">erase()</A><BR>
 <A HREF="#Member Functionsfind()">find()</A><BR>
 <A HREF="#Allocatorsget_allocator()">get_allocator()</A><BR>
 <A HREF="#Member Functionsinsert()">insert()</A><BR>
 <A HREF="#Member Functionskey_comp()">key_comp()</A><BR>
 <A HREF="#Member Functionslower_bound()">lower_bound()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Functionsmax_size()">max_size()</A><BR>
 <A HREF="#Non-member Operatorsoperator!=()">operator!=()</A><BR>
 <A HREF="#Non-member Operatorsoperator&gt;()">operator&gt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&gt;=()">operator&gt;=()</A><BR>
 <A HREF="#Non-member Operatorsoperator&lt;()">operator&lt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&lt;=()">operator&lt;=()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Assignment Operatorsoperator=()">operator=()</A><BR>
 <A HREF="#Non-member Operatorsoperator==()">operator==()</A><BR>
 <A HREF="#Iteratorsrbegin()">rbegin()</A><BR>
 <A HREF="#Iteratorsrend()">rend()</A><BR>
 <A HREF="#Member Functionssize()">size()</A><BR>
 <A HREF="#Member Functionsswap()">swap()</A><BR>
 <A HREF="#Member Functionsupper_bound()">upper_bound()</A><BR>
 <A HREF="#Member Functionsvalue_comp()">value_comp()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>
<PRE>#include &lt;set&gt;
template &lt;class Key, class Compare = less&lt;Key&gt;,
          class Allocator = allocator&lt;Key&gt; &gt; 
class <B>multiset</B>;</PRE>

</PRE>

<A NAME="Description"><H3>Description</H3></A>
<P><B><I>multiset &lt;Key, Compare, Allocator&gt;</I></B> allows fast access to stored key values. The default operation for key comparison is the <SAMP>&lt;</SAMP> operator. Insertion of duplicate keys is allowed with a multiset. </P>
<P><B><I>multiset</I></B> uses bidirectional iterators that point to a stored key. </P>
<P>Any type used for the template parameter <SAMP>Key</SAMP> must include the following (where <SAMP>T</SAMP> is the <SAMP>type</SAMP>, <SAMP>t</SAMP> is a value of <SAMP>T</SAMP> and <SAMP>u</SAMP> is a <SAMP>const</SAMP> <SAMP>value</SAMP> of <SAMP>T</SAMP>): </P>
<TABLE>
<TR><TD VALIGN=top>Copy constructors  </TD>
<TD><SAMP>T(t)</SAMP> and <SAMP>T(u)</SAMP></TD></TR>
<TR><TD VALIGN=top>Destructor  </TD>
<TD><SAMP>t.~T()</SAMP></TD></TR>
<TR><TD VALIGN=top>Address of  </TD>
<TD><SAMP>&amp;t</SAMP> and <SAMP>&amp;u</SAMP> yielding <SAMP>T*</SAMP> and <SAMP>const T*</SAMP> respectively</TD></TR>
<TR><TD VALIGN=top>Assignment  </TD>
<TD><SAMP>t = a</SAMP> where <SAMP>a</SAMP> is a (possibly <SAMP>const</SAMP>) value of <SAMP>T</SAMP></TD></TR>
</TABLE>
<P>The <SAMP>type</SAMP> used for the <SAMP>Compare</SAMP> template parameter must satisfy the requirements for binary functions. </P>

<A NAME="Interface"><H3>Interface</H3></A>
<PRE>
<PRE>template &lt;class Key, class Compare = less&lt;Key&gt;, 
          class Allocator = allocator&lt;Key&gt; &gt;
 class multiset {

public:

// typedefs

   typedef Key key_type;
   typedef Key value_type;
   typedef Compare key_compare;
   typedef Compare value_compare;
   typedef Allocator allocator_type;</PRE>

<UL>
<PRE>   typedef typename
           Allocator::reference        reference;
   typedef typename
           Allocator::const_reference  const_reference;</PRE>

</UL>
<PRE>   class iterator;
   class const_iterator;</PRE>

<UL>
<PRE>   typedef typename
           Allocator::size_type        size_type;
   typedef typename
           Allocator::difference_type  difference_type;</PRE>

</UL>
<PRE>   typedef typename std::reverse_iterator&lt;iterator&gt;
                         reverse_iterator;
   typedef typename std::reverse_iterator&lt;const_iterator&gt;
                         const_reverse_iterator;

// Construct/Copy/Destroy

   explicit multiset (const Compare&amp; = Compare(),
                      const Allocator&amp; = Allocator());
   template &lt;class InputIterator&gt;
    multiset (InputIterator, InputIterator,
              const Compare&amp; = Compare(),
              const Allocator&amp; = Allocator());
   multiset (const multiset&lt;Key, Compare, Allocator&gt;&amp;);
   ~multiset ();
   multiset&lt;Key, Compare, Allocator&gt;&amp; 
            operator= (const multiset&lt;Key, 
                       Compare, Allocator&gt;&amp;);

// Iterators

   iterator begin ();
   const_iterator begin () const;
   iterator end ();
   const_iterator end () const;
   reverse_iterator rbegin ();
   const_reverse_iterator rbegin () const;
   reverse_iterator rend ();
   const_reverse_iterator rend () const;

// Capacity

   bool empty () const;
   size_type size () const;
   size_type max_size () const;

// Modifiers

   iterator insert (const value_type&amp;);
   iterator insert (iterator, const value_type&amp;);
   template &lt;class InputIterator&gt;
    void insert (InputIterator, InputIterator);

   void erase (iterator);
   size_type erase (const key_type&amp;);
   void erase (iterator, iterator);
   void swap (multiset&lt;Key, Compare, Allocator&gt;&amp;);
   void clear ();

// Observers

   key_compare key_comp () const;
   value_compare value_comp () const;

// Multiset operations

   iterator find (const key_type&amp;) const;
   size_type count (const key_type&amp;) const;
   iterator lower_bound (const key_type&amp;) const;
   iterator upper_bound (const key_type&amp;) const;
   pair&lt;iterator, iterator&gt; equal_range 
       (const key_type&amp;) const;
   };

// Non-member Operators

template &lt;class Key, class Compare, class Allocator&gt;
 bool operator==
    (const multiset&lt;Key, Compare, Allocator&gt;&amp;,
     const multiset&lt;Key, Compare, Allocator&gt;&amp;);

template &lt;class Key, class Compare, class Allocator&gt;
 bool operator!=
    (const multiset&lt;Key, Compare, Allocator&gt;&amp;,
     const multiset&lt;Key, Compare, Allocator&gt;&amp;);

template &lt;class Key, class Compare, class Allocator&gt;
 bool operator&lt;
    (const multiset&lt;Key, Compare, Allocator&gt;&amp;,
     const multiset&lt;Key, Compare, Allocator&gt;&amp;);

template &lt;class Key, class Compare, class Allocator&gt;
 bool operator&gt;
    (const multiset&lt;Key, Compare, Allocator&gt;&amp;,
     const multiset&lt;Key, Compare, Allocator&gt;&amp;);

template &lt;class Key, class Compare, class Allocator&gt;
 bool operator&lt;=
    (const multiset&lt;Key, Compare, Allocator&gt;&amp;,
     const multiset&lt;Key, Compare, Allocator&gt;&amp;);

template &lt;class Key, class Compare, class Allocator&gt;
 bool operator&gt;=
    (const multiset&lt;Key, Compare, Allocator&gt;&amp;,
     const multiset&lt;Key, Compare, Allocator&gt;&amp;);

// Specialized Algorithms

template &lt;class Key, class Compare, class Allocator&gt;
 void swap ( multiset&lt;Key, Compare, Allocator&gt;&amp;,
             multiset&lt;Key, Compare, Allocator&gt;&amp;);</PRE>

</PRE>

<A NAME="Constructors"><H3>Constructors</H3></A>


<PRE>explicit <B>multiset</B>(const Compare&amp; comp = Compare(),
                   const Allocator&amp; alloc = Allocator());</PRE>

<UL>
<P>Constructs an empty multiset that uses the optional relation <SAMP>comp</SAMP> to order keys, if it is supplied, and the allocator <SAMP>alloc</SAMP> for all storage management. </P>
</UL>



<PRE>template &lt;class InputIterator&gt;
<B>multiset</B>(InputIterator first, InputIterator last,
          const Compare&amp; = Compare(),
          const Allocator&amp; = Allocator());</PRE>

<UL>
<P>Constructs a multiset containing values in the range <SAMP>[first, last).</SAMP></P>
</UL>



<PRE><B>multiset</B>(const multiset&lt;Key, Compare, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Creates a new multiset by copying all key values from <SAMP>x</SAMP>. </P>
</UL>


<A NAME="Destructors"><H3>Destructors</H3></A>


<PRE><B>~multiset</B>();</PRE>

<UL>
<P>Releases any allocated memory for this multiset.</P>
</UL>


<A NAME="Assignment Operators"><H3>Assignment Operators</H3></A>


<A NAME="Assignment Operatorsoperator=()"></A><PRE>multiset&lt;Key, Compare, Allocator&gt;&amp; 
<B>operator=</B>(const multiset&lt;Key, Compare, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Replaces the contents of <SAMP>*this</SAMP> with a copy of the contents of <SAMP>x</SAMP>. </P>
</UL>


<A NAME="Allocators"><H3>Allocators</H3></A>


<A NAME="Allocatorsget_allocator()"></A><PRE>allocator_type 
<B>get_allocator</B>() const;</PRE>

<UL>
<P>Returns a copy of the allocator used by self for storage management.</P>
</UL>


<A NAME="Iterators"><H3>Iterators</H3></A>


<A NAME="Iteratorsbegin()"></A><PRE>iterator 
<B>begin</B>();</PRE>

<UL>
<P>Returns an <SAMP>iterator</SAMP> pointing to the first element stored in the multiset. "First" is defined by the multiset's comparison operator, <SAMP>Compare</SAMP>. </P>
</UL>



<PRE>const_iterator 
<B>begin</B>();</PRE>

<UL>
<P>Returns a <SAMP>const_iterator</SAMP> pointing to the first element stored in the multiset. </P>
</UL>



<A NAME="Iteratorsend()"></A><PRE>iterator 
<B>end</B>();</PRE>

<UL>
<P>Returns an <SAMP>iterator</SAMP> pointing to the last element stored in the multiset (in other words, the off-the-end value). </P>
</UL>



<PRE>const_iterator 
<B>end</B>();</PRE>

<UL>
<P>Returns a <SAMP>const_iterator</SAMP> pointing to the last element stored in the multiset (in other words, the off-the-end value). </P>
</UL>



<A NAME="Iteratorsrbegin()"></A><PRE>reverse_iterator 
<B>rbegin</B>();</PRE>

<UL>
<P>Returns a <SAMP>reverse_iterator</SAMP> pointing to the first element stored in the multiset. "First" is defined by the multiset's comparison operator, <SAMP>Compare</SAMP>. </P>
</UL>



<PRE>const_reverse_iterator 
<B>rbegin</B>();</PRE>

<UL>
<P>Returns a <SAMP>const_reverse_iterator</SAMP> pointing to the first element stored in the multiset. </P>
</UL>



<A NAME="Iteratorsrend()"></A><PRE>reverse_iterator 
<B>rend</B>();</PRE>

<UL>
<P>Returns a <SAMP>reverse_iterator</SAMP> pointing to the last element stored in the multiset (in other words, the off-the-end value). </P>
</UL>



<PRE>const_reverse_iterator 
<B>rend</B>();</PRE>

<UL>
<P>Returns a <SAMP>const_reverse_iterator</SAMP> pointing to the last element stored in the multiset (in other words, the off-the-end value). </P>
</UL>


<A NAME="Member Functions"><H3>Member Functions</H3></A>


<A NAME="Member Functionsclear()"></A><PRE>void
<B>clear</B>();</PRE>

<UL>
<P>Erases all elements from the self.</P>
</UL>



<A NAME="Member Functionscount()"></A><PRE>size_type 
<B>count</B>(const key_type&amp; x) const;</PRE>

<UL>
<P>Returns the number of elements in the multiset with the key value <SAMP>x</SAMP>. </P>
</UL>



<A NAME="Member Functionsempty()"></A><PRE>bool 
<B>empty</B>() const;</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the multiset is empty, <SAMP>false</SAMP> otherwise.</P>
</UL>



<A NAME="Member Functionsequal_range()"></A><PRE>pair&lt;iterator,iterator&gt; 
<B>equal_range</B>(const key_type&amp; x)const;</PRE>

<UL>
<P>Returns the pair <SAMP>(lower_bound(x), upper_bound(x))</SAMP>.</P>
</UL>



<A NAME="Member Functionserase()"></A><PRE>size_type 
<B>erase</B>(const key_type&amp; x);</PRE>

<UL>
<P>Deletes all elements with the key value <SAMP>x</SAMP> from the multiset, if any exist. Returns the number of deleted elements.</P>
</UL>



<PRE>void
<B>erase</B>(iterator position);</PRE>

<UL>
<P>Deletes the multiset element pointed to by the iterator <SAMP>position</SAMP>. Returns an iterator pointing to the element following the deleted element, or <SAMP>end()</SAMP>, if the deleted item was the last one in this list.</P>
</UL>



<PRE>void
<B>erase</B>(iterator first, iterator last);</PRE>

<UL>
<P>If the iterators <SAMP>first</SAMP> and <SAMP>last</SAMP> point to the same multiset and last is reachable from first, all elements in the range (<SAMP>first, last</SAMP>) are deleted from the multiset. Returns an iterator pointing to the element following the last deleted element or <SAMP>end()</SAMP>, if there were no elements after the deleted range.</P>
</UL>



<A NAME="Member Functionsfind()"></A><PRE>iterator 
<B>find</B>(const key_type&amp; x) const;</PRE>

<UL>
<P>Searches the multiset for a key value <SAMP>x</SAMP> and returns an iterator to that key if it is found. If such a value is not found, the iterator <SAMP>end()</SAMP> is returned. </P>
</UL>



<A NAME="Member Functionsinsert()"></A><PRE>iterator 
<B>insert</B>(const value_type&amp; x);
iterator 
<B>insert</B>(iterator position, const value_type&amp; x);</PRE>

<UL>
<P><SAMP>x</SAMP> is inserted into the multiset. A position may be supplied as a hint regarding where to do the insertion. If the insertion is done right after position, then it takes amortized constant time. Otherwise, it takes <SAMP>O(log N)</SAMP> time. </P>
</UL>



<PRE>template &lt;class InputIterator&gt;
void 
<B>insert</B>(InputIterator first, InputIterator last);</PRE>

<UL>
<P>Copies of each element in the range <SAMP>[first, last)</SAMP> are inserted into the multiset. This <SAMP>insert</SAMP> takes approximately <SAMP>O(N*log(size()+N))</SAMP> time. </P>
</UL>



<A NAME="Member Functionskey_comp()"></A><PRE>key_compare 
<B>key_comp</B>() const;</PRE>

<UL>
<P>Returns a function object capable of comparing key values using the comparison operation, <SAMP>Compare</SAMP>, of the current multiset. </P>
</UL>



<A NAME="Member Functionslower_bound()"></A><PRE>iterator 
<B>lower_bound</B>(const key_type&amp; x) const;</PRE>

<UL>
<P>Returns an iterator to the first element whose key is greater than or equal to <SAMP>x</SAMP>. If no such element exists, <SAMP>end()</SAMP> is returned. </P>
</UL>



<A NAME="Member Functionsmax_size()"></A><PRE>size_type 
<B>max_size</B>() const;</PRE>

<UL>
<P>Returns the maximum possible size of the multiset <SAMP>size_type.</SAMP></P>
</UL>



<A NAME="Member Functionssize()"></A><PRE>size_type
<B>size</B>() const;</PRE>

<UL>
<P>Returns the number of elements in the multiset.</P>
</UL>



<A NAME="Member Functionsswap()"></A><PRE>void 
<B>swap</B>(multiset&lt;Key, Compare, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Swaps the contents of the multiset <SAMP>x</SAMP> with the current multiset, <SAMP>*this</SAMP>. </P>
</UL>



<A NAME="Member Functionsupper_bound()"></A><PRE>iterator 
<B>upper_bound</B>(const key_type&amp; x) const;</PRE>

<UL>
<P>Returns an iterator to the first element whose key is smaller than or equal to <SAMP>x.</SAMP> If no such element exists, then <SAMP>end()</SAMP> is returned. </P>
</UL>



<A NAME="Member Functionsvalue_comp()"></A><PRE>value_compare 
<B>value_comp</B>() const;</PRE>

<UL>
<P>Returns a function object capable of comparing key values using the comparison operation, <SAMP>Compare</SAMP>, of the current multiset.</P>
</UL>


<A NAME="Non-member Operators"><H3>Non-member Operators</H3></A>


<A NAME="Non-member Operatorsoperator==()"></A><PRE>template &lt;class Key, class Compare, class Allocator&gt;
<B>operator==</B>(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,
            const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if all elements in <SAMP>x</SAMP> are element-wise equal to all elements in <SAMP>y</SAMP>, using <SAMP>(T::operator==)</SAMP>. Otherwise it returns <SAMP>false</SAMP>. </P>
</UL>



<A NAME="Non-member Operatorsoperator!=()"></A><PRE>template &lt;class Key, class Compare, class Allocator&gt;
<B>operator!=</B>(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,
            const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>!(x==y)</SAMP>. </P>
</UL>



<A NAME="Non-member Operatorsoperator&lt;()"></A><PRE>template &lt;class Key, class Compare, class Allocator&gt;
<B>operator&lt;</B>(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,
           const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if <SAMP>x</SAMP> is lexicographically less than <SAMP>y</SAMP>. Otherwise, it returns <SAMP>false</SAMP>. </P>
</UL>



<A NAME="Non-member Operatorsoperator&gt;()"></A><PRE>template &lt;class Key, class Compare, class Allocator&gt;
<B>operator&gt;</B>(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,
           const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>y &lt; x</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&lt;=()"></A><PRE>template &lt;class Key, class Compare, class Allocator&gt;
<B>operator&lt;=</B>(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,
           const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>!(y &lt; x)</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&gt;=()"></A><PRE>template &lt;class Key, class Compare, class Allocator&gt;
<B>operator&gt;=</B>(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,
           const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>!(x &lt; y)</SAMP>.</P>
</UL>


<A NAME="Specialized Algorithms"><H3>Specialized Algorithms</H3></A>


<PRE>template &lt;class Key, class Compare, class Allocator&gt;
void <B>swap</B>(multiset&lt;Key,Compare,Allocator&gt;&amp; a,
           multiset&lt;Key,Compare,Allocator&gt;&amp;b);</PRE>

<UL>
<P>Swaps the contents of <SAMP>a</SAMP> and <SAMP>b</SAMP>.</P>
</UL>


<A NAME="Example"><H3>Example</H3></A>
<UL>
<PRE>//
// multiset.cpp
//
#include &lt;set&gt;
#include &lt;iostream&gt;
using namespace std;

 typedef <B>multiset</B>&lt;int, less&lt;int&gt;, allocator&gt; set_type;

 ostream&amp; operator&lt;&lt;(ostream&amp; out, const set_type&amp; s)
 {
   copy(s.begin(),s.end(),
     ostream_iterator&lt;set_type::value_type,char&gt;(cout," "));
   return out;
 }


 int main(void)
 {
   // create a multiset of ints
   set_type  si;
   int  i;

   for (int j = 0; j &lt; 2; j++)
   {
     for(i = 0; i &lt; 10; ++i) {
       // insert values with a hint
       si.insert(si.begin(), i);
     }
   }

   // print out the multiset
   cout &lt;&lt; si &lt;&lt; endl;

   // Make another int multiset and an empty multiset
   set_type si2, siResult;
   for (i = 0; i &lt; 10; i++)
      si2.insert(i+5);
   cout &lt;&lt; si2 &lt;&lt; endl;

   // Try a couple of set algorithms
   set_union(si.begin(),si.end(),si2.begin(),si2.end(),
          inserter(siResult,siResult.begin()));
   cout &lt;&lt; "Union:" &lt;&lt; endl &lt;&lt; siResult &lt;&lt; endl;

   siResult.erase(siResult.begin(),siResult.end());
   set_intersection(si.begin(),si.end(),
          si2.begin(),si2.end(),
          inserter(siResult,siResult.begin()));
   cout &lt;&lt; "Intersection:" &lt;&lt; endl &lt;&lt; siResult &lt;&lt; endl;
  
   return 0;
 }</PRE>

</UL>
<P><B>Program Output</B></P>
<UL>
<PRE>
0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
5 6 7 8 9 10 11 12 13 14
Union:
0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 11 12 13 14
Intersection:
5 6 7 8 9</PRE>

</UL>

<A NAME="Warnings"><H3>Warnings</H3></A>
<P>Member function templates are used in all containers included in the Standard Template Library. An example of this feature is the constructor for <B><I>multiset&lt;Key, Compare, Allocator&gt;</I></B>, which takes two templatized iterators: </P>
<UL>
<PRE>template &lt;class InputIterator&gt;
multiset (InputIterator, InputIterator,
          const Compare&amp; = Compare(),
          const Allocator&amp; = Allocator());</PRE>

</UL>
<P><B><I>multiset</I></B> also has an <SAMP>insert</SAMP> function of this type. These functions, when not restricted by compiler limitations, allow you to use any type of input iterator as arguments. For compilers that do not support this feature, substitute functions allow you to use an iterator obtained from the same type of container as the one you are constructing (or calling a member function on). You can also use a pointer to the type of element you have in the container. </P>
<P>For example, if your compiler does not support member function templates, you can construct a <B><I>multiset</I></B> in the following two ways: </P>
<UL>
<PRE>int intarray[10];
multiset&lt;int&gt; first_multiset(intarray, intarray +10);
multiset&lt;int&gt; second_multiset(first_multiset.begin(),
              first_multiset.end());</PRE>

</UL>
<P>but not this way:</P>
<UL>
<PRE><SAMP>multiset&lt;long&gt;</SAMP>
 long_multiset(first_multiset.begin(),first_multiset.end());</PRE>

</UL>
<P>since the <SAMP>long_multiset</SAMP> and <SAMP>first_multiset</SAMP> are not the same type. </P>
<P>Also, many compilers do not support default template arguments. If your compiler is one of these you always need to supply the <SAMP>Compare</SAMP> template argument and the <SAMP>Allocator</SAMP> template argument. For instance, you have to write:</P>
<P><SAMP>multiset&lt;int, less&lt;int&gt;, allocator&lt;int&gt; &gt;</SAMP></P>
<P>instead of:</P>
<P><SAMP>multiset&lt;int&gt;</SAMP></P>
<P>If your compiler does not support namespaces, then you do not need the using declaration for <SAMP>std</SAMP>.</P>

<A NAME="See Also"><H3>See Also</H3></A>
<P><B><I><A HREF="all_7029.htm">allocator</A></I></B>, <B><I><A HREF="Con_2487.htm">Containers</A></I></B>, <B><I><A HREF="Ite_5295.htm">Iterators</A></I></B>, <B><I><A HREF="set_1649.htm">set</A></I></B></P>


<BR>
<HR>
<A HREF="mul_0796.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="neg_4682.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<BR>&copy;Copyright 1999, Rogue Wave Software, Inc.<BR>Send <A HREF="mailto:onlinedocs@roguewave.com">mail</A> to report errors or comment on the documentation.
<BR>
OEM Release</BODY></HTML>
