<HTML><HEAD><TITLE>2.5 Iterator Operations</TITLE></HEAD>
<BODY BGCOLOR=#FFFFFF>
<A HREF="../index.htm"><IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0></A><BR>
<A HREF="2-4.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="3.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<H2>2.5 Iterator Operations</H2>
<A NAME="idx38"><!></A>
<P>The Standard C++ Library provides two functions that can be used to manipulate iterators. The function <SAMP>advance()</SAMP> takes an iterator and a numeric value as argument, and modifies the iterator by moving the given amount.</P>
<UL>
<PRE>
void advance (InputIterator &amp; iter, Distance &amp; n);</PRE>
</UL>
<P>For random access iterators this is the same as <SAMP>iter + n;</SAMP> however, the function is useful because it is designed to operate with all forms of iterators. For forward iterators the numeric distance must be positive, whereas for bidirectional or random access iterators the value can be either positive or negative. The operation is efficient (constant time) only for random access iterators. In all other cases, it is implemented as a loop that invokes either the operators <SAMP>++</SAMP> or <SAMP>--</SAMP> on the iterator, and therefore takes time proportional to the distance traveled. The <SAMP>advance()</SAMP> function does not check to ensure the validity of the operations on the underlying iterator.</P>
<A NAME="idx39"><!></A>
<P>The second function, <SAMP>distance()</SAMP>, returns the number of iterator operations necessary to move from one element in a sequence to another. The description of this function is as follows:</P>
<UL>
<PRE>
Distance distance (InputIterator first, InputIterator last);</PRE>
</UL>
<P>The result is returned in the third argument, which is passed by reference. Distance will <I>increment</I> this value by the number of times the operator <SAMP>++</SAMP> must be executed to move from <SAMP>first</SAMP> to <SAMP>last</SAMP>. Always be sure that the variable passed through this argument is properly initialized before invoking the function. </P>
<BLOCKQUOTE><HR>
<B>NOTE: The above definition of distance assumes that your compiler supports partial specialization. If it does not, then you must use the following alternate definition:<br>void distance (InputIterator first, InputIterator last, Distance &amp;n);
</B><HR></BLOCKQUOTE>


<BR>
<HR>
<A HREF="2-4.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="3.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><P>OEM Edition, OEM Edition, &copy;Copyright 1999, Rogue Wave Software, Inc.<BR><A HREF="contact.htm">Contact</A> Rogue Wave about documentation or support issues.</P>
</BODY></HTML>
