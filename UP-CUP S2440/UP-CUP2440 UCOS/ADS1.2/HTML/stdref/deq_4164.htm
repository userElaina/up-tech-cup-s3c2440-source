<HTML><HEAD><TITLE>deque</TITLE></HEAD><BODY BGCOLOR=#FFFFFF>
<IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0><BR>
<A HREF="cty_1366.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="dis_0186.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><BR>

<H2>deque</H2>
<PRE><HR>Container
<HR></PRE>
<UL>
<LI><A HREF="#Summary">Summary</A></LI>
<LI><A HREF="#memindex">Data Type and Member Function Indexes</A></LI>
<LI><A HREF="#Synopsis">Synopsis</A></LI>
<LI><A HREF="#Description">Description</A></LI>
<LI><A HREF="#Interface">Interface</A></LI>
<LI><A HREF="#Constructors">Constructors</A></LI>
<LI><A HREF="#Destructors">Destructors</A></LI>
<LI><A HREF="#Allocators">Allocators</A></LI>
<LI><A HREF="#Iterators">Iterators</A></LI>
<LI><A HREF="#Assignment Operators">Assignment Operators</A></LI>
<LI><A HREF="#Reference Operators">Reference Operators</A></LI>
<LI><A HREF="#Member Functions">Member Functions</A></LI>
<LI><A HREF="#Non-member Functions">Non-member Functions</A></LI>
<LI><A HREF="#Specialized Algorithms">Specialized Algorithms</A></LI>
<LI><A HREF="#Example">Example</A></LI>
<LI><A HREF="#Warnings">Warnings</A></LI>

</UL>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A sequence that supports random access iterators and efficient insertion/deletion at both beginning and end.</P>
<A NAME="memindex"><H3>Data Type and Member Function Indexes<BR>(exclusive of constructors and destructors)</H3></A>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Data Types</B></TD></TR><TR><TD VALIGN=top><A HREF="#Allocatorsallocator">allocator</A><BR>
</TD></TR>
</TABLE></UL>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Member Functions</B></TD></TR><TR><TD VALIGN=top><A HREF="#Member Functionsassign()">assign()</A><BR>
 <A HREF="#Member Functionsat()">at()</A><BR>
 <A HREF="#Member Functionsback()">back()</A><BR>
 <A HREF="#Iteratorsbegin()">begin()</A><BR>
 <A HREF="#Member Functionsclear()">clear()</A><BR>
 <A HREF="#Member Functionsempty()">empty()</A><BR>
 <A HREF="#Iteratorsend()">end()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Functionserase()">erase()</A><BR>
 <A HREF="#Member Functionsfront()">front()</A><BR>
 <A HREF="#Allocatorsget_allocator()">get_allocator()</A><BR>
 <A HREF="#Member Functionsinsert()">insert()</A><BR>
 <A HREF="#Member Functionsmax_size()">max_size()</A><BR>
 <A HREF="#Non-member Functionsoperator!=()">operator!=()</A><BR>
 <A HREF="#Non-member Functionsoperator&gt;()">operator&gt;()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Non-member Functionsoperator&gt;=()">operator&gt;=()</A><BR>
 <A HREF="#Non-member Functionsoperator&lt;()">operator&lt;()</A><BR>
 <A HREF="#Non-member Functionsoperator&lt;=()">operator&lt;=()</A><BR>
 <A HREF="#Assignment Operatorsoperator=()">operator=()</A><BR>
 <A HREF="#Non-member Functionsoperator==()">operator==()</A><BR>
 <A HREF="#Reference Operatorsoperator[]()">operator[]()</A><BR>
 <A HREF="#Member Functionspop_back()">pop_back()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Functionspop_front()">pop_front()</A><BR>
 <A HREF="#Member Functionspush_back()">push_back()</A><BR>
 <A HREF="#Member Functionspush_front()">push_front()</A><BR>
 <A HREF="#Iteratorsrbegin()">rbegin()</A><BR>
 <A HREF="#Iteratorsrend()">rend()</A><BR>
 <A HREF="#Member Functionsresize()">resize()</A><BR>
 <A HREF="#Member Functionssize()">size()</A><BR>
 <A HREF="#Member Functionsswap()">swap()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>
<PRE>#include &lt;deque&gt;

template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
 class deque;</PRE>

</PRE>

<A NAME="Description"><H3>Description</H3></A>
<P><B><I>deque&lt;T, Allocator&gt;</I></B> is a type of sequence that supports random access iterators. It supports constant time insert and erase operations at the beginning or the end of the container. Insertion and erase in the middle take linear time. Storage management is handled by the <SAMP>Allocator</SAMP> template parameter. </P>
<P>Any type used for the template parameter <SAMP>T</SAMP> must include the following (where <SAMP>T</SAMP> is the <SAMP>type</SAMP>, <SAMP>t</SAMP> is a <SAMP>value</SAMP> of <SAMP>T</SAMP> and <SAMP>u</SAMP> is a <SAMP>const</SAMP> <SAMP>value</SAMP> of <SAMP>T</SAMP>): </P>
<TABLE>
<TR><TD VALIGN=top><SAMP>Copy constructors   </TD>
<TD>T(t)</SAMP> and <SAMP>T(u)</SAMP></TD></TR>
<TR><TD VALIGN=top><SAMP>Destructor  </TD>
<TD>t.~T()</SAMP></TD></TR>
<TR><TD VALIGN=top><SAMP>Address of  </TD>
<TD>&amp;t</SAMP> and <SAMP>&amp;u</SAMP> yielding <SAMP>T*</SAMP> and <SAMP>const T*</SAMP> respectively</TD></TR>
<TR><TD VALIGN=top><SAMP>Assignment  </TD>
<TD>t = a</SAMP> where <SAMP>a</SAMP> is a (possibly <SAMP>const</SAMP>) value of <SAMP>T</SAMP></TD></TR>
</TABLE>

<A NAME="Interface"><H3>Interface</H3></A>
<UL>
<PRE>template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
 class deque {

public:

 // Types

   class iterator; 
   class const_iterator;

   typedef T value_type;
   typedef Allocator allocator_type;
   typedef typename
           Allocator::reference        reference;
   typedef typename
           Allocator::const_reference  const_reference;
   typedef typename
           Allocator::size_type        size_type;
   typedef typename
           Allocator::difference_type  difference_type;
   typedef typename
           std::reverse_iterator&lt;iterator&gt; reverse_iterator;
   typedef typename
           std::reverse_iterator&lt;const_iterator&gt;
                                 const_reverse_iterator;

 // Construct/Copy/Destroy

   explicit deque (const Allocator&amp; = Allocator());
   explicit deque (size_type);
   deque (size_type, const T&amp; value, 
          const Allocator&amp; = Allocator ());
   deque (const deque&lt;T,Allocator&gt;&amp;);
   template &lt;class InputIterator&gt;
    deque (InputIterator, InputIterator, 
           const Allocator&amp; = Allocator ());
   ~deque ();
   deque&lt;T,Allocator&gt;&amp; operator= 
                       (const deque&lt;T,Allocator&gt;&amp;);
   template &lt;class InputIterator&gt;
    void assign (InputIterator, InputIterator);
   void assign (size_type, const T&amp;);
   allocator_type get allocator () const;

 // Iterators

   iterator begin ();
   const_iterator begin () const;
   iterator end ();
   const_iterator end () const;
   reverse_iterator rbegin ();
   const_reverse_iterator rbegin () const;
   reverse_iterator rend ();
   const_reverse_iterator rend () const;

// Capacity

   size_type size () const;
   size_type max_size () const;
   void resize (size_type);
   void resize (size_type, T);
   bool empty () const;

// Element access

   reference operator[] (size_type);
   const_reference operator[] (size_type) const;
   reference at (size_type);
   const_reference at (size_type) const;
   reference front ();
   const_reference front () const;
   reference back ();
   const_reference back () const;

 // Modifiers

   void push_front (const T&amp;);
   void push_back (const T&amp;);
   iterator insert (iterator, const T&amp;);
   void insert (iterator, size_type, const T&amp;);
   template &lt;class InputIterator&gt;
    void insert (iterator, InputIterator, InputIterator);

   void pop_front ();
   void pop_back ();

   iterator erase (iterator);
   iterator erase (iterator, iterator);
   void swap (deque&lt;T, Allocator&gt;&amp;);
   void clear();
};

 // Non-member Operators

template &lt;class T, class Allocator&gt;
 bool operator== (const deque&lt;T, Allocator&gt;&amp;, 
                  const deque&lt;T, Allocator&gt;&amp;);

template &lt;class T, class Allocator&gt;
 bool operator!= (const deque&lt;T, Allocator&gt;&amp;, 
                  const deque&lt;T, Allocator&gt;&amp;);


template &lt;class T, class Allocator&gt;
 bool operator&lt; (const deque&lt;T, Allocator&gt;&amp;, 
                 const deque&lt;T, Allocator&gt;&amp;);

template &lt;class T, class Allocator&gt;
 bool operator&gt; (const deque&lt;T, Allocator&gt;&amp;, 
                 const deque&lt;T, Allocator&gt;&amp;);

template &lt;class T, class Allocator&gt;
 bool operator&lt;= (const deque&lt;T, Allocator&gt;&amp;, 
                 const deque&lt;T, Allocator&gt;&amp;);

template &lt;class T, class Allocator&gt;
 bool operator&gt;= (const deque&lt;T, Allocator&gt;&amp;, 
                 const deque&lt;T, Allocator&gt;&amp;);


// Specialized Algorithms

template &lt;class T, class Allocator&gt;
 voice swap (deque&lt;T, Allocator&gt;&amp;, deque&lt;T, Allocator&gt;&amp;);</PRE>

</UL>

<A NAME="Constructors"><H3>Constructors</H3></A>


<PRE>explicit 
<B>deque</B>(const Allocator&amp; alloc = Allocator());</PRE>

<UL>
<P>The default constructor. Creates a deque of zero elements. The deque uses the allocator <SAMP>alloc</SAMP> for all storage management.</P>
</UL>



<PRE>explicit 
<B>deque</B>(size_type n);</PRE>

<UL>
<P>Creates a list of length <SAMP>n</SAMP>, containing <SAMP>n</SAMP> copies of the default value for type <SAMP>T</SAMP>. <SAMP>T</SAMP> must have a default constructor. The deque uses the allocator Allocator() for all storage management. </P>
</UL>



<PRE><B>deque</B>(size_type n, const T&amp; value, 
       const Allocator&amp; alloc = Allocator());</PRE>

<UL>
<P>Creates a list of length <SAMP>n</SAMP>, containing <SAMP>n</SAMP> copies of <SAMP>value</SAMP>. The deque uses the allocator <SAMP>alloc</SAMP> for all storage management. </P>
</UL>



<PRE><B>deque</B>(const deque&lt;T, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Creates a copy of <SAMP>x</SAMP>.</P>
</UL>



<PRE>template &lt;class InputIterator&gt;
<B>deque</B>(InputIterator first, InputIterator last, 
       const Allocator&amp; alloc = Allocator());</PRE>

<UL>
<P>Creates a deque of length <SAMP>last - first</SAMP>, filled with all values obtained by dereferencing the <SAMP>InputIterators</SAMP> on the range <SAMP>[first, last)</SAMP>. The deque uses the allocator <SAMP>alloc</SAMP> for all storage management. </P>
</UL>


<A NAME="Destructors"><H3>Destructors</H3></A>


<PRE><B>~deque</B>();</PRE>

<UL>
<P>Releases any allocated memory for self.</P>
</UL>


<A NAME="Allocators"><H3>Allocators</H3></A>


<A NAME="Allocatorsallocator"></A><PRE><B>allocator</B>
<A NAME="Allocatorsget_allocator()"></A>allocator_type <B>get_allocator</B>() const;</PRE>

<UL>
<P>Returns a copy of the allocator used by self for storage management.</P>
</UL>


<A NAME="Iterators"><H3>Iterators</H3></A>


<A NAME="Iteratorsbegin()"></A><PRE>iterator <B>begin</B>();</PRE>

<UL>
<P>Returns a random access iterator that points to the first element.</P>
</UL>



<PRE>const_iterator <B>begin</B>() const;</PRE>

<UL>
<P>Returns a constant random access iterator that points to the first element.</P>
</UL>



<A NAME="Iteratorsend()"></A><PRE>iterator <B>end</B>();</PRE>

<UL>
<P>Returns a random access iterator that points to the past-the-end value.</P>
</UL>



<PRE>const_iterator <B>end</B>() const;</PRE>

<UL>
<P>Returns a constant random access iterator that points to the past-the-end value.</P>
</UL>



<A NAME="Iteratorsrbegin()"></A><PRE>reverse_iterator <B>rbegin</B>();</PRE>

<UL>
<P>Returns a random access <SAMP>reverse_iterator</SAMP> that points to the past-the-end value.</P>
</UL>



<PRE>const_reverse_iterator <B>rbegin</B>() const;</PRE>

<UL>
<P>Returns a constant random access reverse iterator that points to the past-the-end value.</P>
</UL>



<A NAME="Iteratorsrend()"></A><PRE>reverse_iterator <B>rend</B>();</PRE>

<UL>
<P>Returns a random access <SAMP>reverse_iterator</SAMP> that points to the first element.</P>
</UL>



<PRE>const_reverse_iterator <B>rend</B>() const;</PRE>

<UL>
<P>Returns a constant random access reverse iterator that points to the first element.</P>
</UL>


<A NAME="Assignment Operators"><H3>Assignment Operators</H3></A>


<A NAME="Assignment Operatorsoperator=()"></A><PRE>deque&lt;T, Allocator&gt;&amp; 
<B>operator=</B>(const deque&lt;T, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Erases all elements in self, then inserts into self a copy of each element in <SAMP>x</SAMP>. Returns a reference to self.</P>
</UL>


<A NAME="Reference Operators"><H3>Reference Operators</H3></A>


<A NAME="Reference Operatorsoperator[]()"></A><PRE>reference <B>operator[]</B>(size_type n);</PRE>

<UL>
<P>Returns a <SAMP>reference</SAMP> to element <SAMP>n</SAMP> of self.   The result can be used as an lvalue. The index <SAMP>n</SAMP> must be between <SAMP>0</SAMP> and the <SAMP>size() - 1</SAMP>..</P>
</UL>



<PRE>const_reference <B>operator[]</B>(size_type n) const;</PRE>

<UL>
<P>Returns a constant reference to element <SAMP>n</SAMP> of self. The index <SAMP>n</SAMP> must be between <SAMP>0</SAMP> and the <SAMP>size() - 1</SAMP>.</P>
</UL>


<A NAME="Member Functions"><H3>Member Functions</H3></A>


<PRE>template &lt;class InputIterator&gt;
<A NAME="Member Functionsassign()"></A>void
<B>assign</B>(InputIterator first, InputIterator last);</PRE>

<UL>
<P>Erases all elements contained in self, then inserts new elements from the range <SAMP>[first, last)</SAMP>.</P>
</UL>



<PRE>void 
<B>assign</B>(size_type n, const T&amp; t);</PRE>

<UL>
<P>Erases all elements contained in self, then inserts <SAMP>n</SAMP> instances of the value of <SAMP>t.</SAMP></P>
</UL>



<A NAME="Member Functionsat()"></A><PRE>reference 
<B>at</B>(size_type n);</PRE>

<UL>
<P>Returns a reference to element <SAMP>n</SAMP> of self. The result can be used as an lvalue. The index <SAMP>n</SAMP> must be between <SAMP>0</SAMP> and the <SAMP>size() - 1</SAMP>.</P>
</UL>



<PRE>const_reference 
<B>at</B>(size_type) const;</PRE>

<UL>
<P>Returns a constant reference to element <SAMP>n</SAMP> of self. The index <SAMP>n</SAMP> must be between <SAMP>0</SAMP> and the <SAMP>size() - 1</SAMP>.</P>
</UL>



<A NAME="Member Functionsback()"></A><PRE>reference 
<B>back</B>();</PRE>

<UL>
<P>Returns a reference to the last element.</P>
</UL>



<PRE>const_reference 
<B>back</B>() const;</PRE>

<UL>
<P>Returns a constant reference to the last element.</P>
</UL>



<A NAME="Member Functionsclear()"></A><PRE>void
<B>clear</B>();</PRE>

<UL>
<P>Erases all elements from the self.</P>
</UL>



<A NAME="Member Functionsempty()"></A><PRE>bool 
<B>empty</B>() const;</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the size of self is zero.</P>
</UL>



<A NAME="Member Functionsfront()"></A><PRE>reference 
<B>front</B>();</PRE>

<UL>
<P>Returns a reference to the first element.</P>
</UL>



<PRE>const_reference 
<B>front</B>() const;</PRE>

<UL>
<P>Returns a constant reference to the first element.</P>
</UL>



<A NAME="Member Functionserase()"></A><PRE>iterator
<B>erase</B>(iterator first, iterator last);</PRE>

<UL>
<P>Deletes the elements in the range (<SAMP>first, last</SAMP>). Returns an iterator pointing to the element following the last deleted element, or <SAMP>end()</SAMP> if there were no elements after the deleted range.</P>
</UL>



<PRE>iterator
<B>erase</B>(iterator position);</PRE>

<UL>
<P>Removes the element pointed to by <SAMP>position</SAMP>. Returns an iterator pointing to the element following the deleted element, or <SAMP>end()</SAMP> if there were no elements after the deleted range.</P>
</UL>



<A NAME="Member Functionsinsert()"></A><PRE>iterator 
<B>insert</B>(iterator position, const T&amp; x);</PRE>

<UL>
<P>Inserts <SAMP>x</SAMP> before <SAMP>position</SAMP>. The return value points to the inserted <SAMP>x</SAMP>.</P>
</UL>



<PRE>void 
<B>insert</B>(iterator position, size_type n, const T&amp; x);</PRE>

<UL>
<P>Inserts <SAMP>n</SAMP> copies of <SAMP>x</SAMP> before <SAMP>position</SAMP>.</P>
</UL>



<PRE>template &lt;class InputIterator&gt;
void 
<B>insert</B>(iterator position, InputIterator first,
        InputIterator last);</PRE>

<UL>
<P>Inserts copies of the elements in the range <SAMP>(first, last]</SAMP> before <SAMP>position</SAMP>.</P>
</UL>



<A NAME="Member Functionsmax_size()"></A><PRE>size_type 
<B>max_size</B>() const;</PRE>

<UL>
<P>Returns <SAMP>size()</SAMP> of the largest possible deque.</P>
</UL>



<A NAME="Member Functionspop_back()"></A><PRE>void 
<B>pop_back</B>();</PRE>

<UL>
<P>Removes the last element. Note that this function does not return the element.</P>
</UL>



<A NAME="Member Functionspop_front()"></A><PRE>void 
<B>pop_front</B>();</PRE>

<UL>
<P>Removes the first element. Note that this function does not return the element.</P>
</UL>



<A NAME="Member Functionspush_back()"></A><PRE>void
<B>push_back</B>(const T&amp; x);</PRE>

<UL>
<P>Appends a copy of <SAMP>x</SAMP> to the end.</P>
</UL>



<A NAME="Member Functionspush_front()"></A><PRE>void 
<B>push_front</B>(const T&amp; x);</PRE>

<UL>
<P>Inserts a copy of <SAMP>x</SAMP> at the front.</P>
</UL>



<A NAME="Member Functionsresize()"></A><PRE>void 
<B>resize</B>(size_type sz);</PRE>

<UL>
<P>Alters the size of self. If the new size (<SAMP>sz</SAMP>) is greater than the current size, then <SAMP>sz-size()</SAMP> copies of the default value of type <SAMP>T</SAMP> are inserted at the end of the deque. If the new size is smaller than the current capacity, then the deque is truncated by erasing <SAMP>size()-sz</SAMP> elements off the end. Otherwise, no action is taken. Type <SAMP>T</SAMP> must have a default constructor.</P>
</UL>



<PRE>void 
<B>resize</B>(size_type sz, T c);</PRE>

<UL>
<P>Alters the size of self. If the new size (<SAMP>sz</SAMP>) is greater than the current size, then <SAMP>sz-size()</SAMP> <SAMP>c</SAMP>'s are inserted at the end of the deque. If the new size is smaller than the current capacity, then the deque is truncated by erasing <SAMP>size()-sz</SAMP> elements off the end. Otherwise, no action is taken.</P>
</UL>



<A NAME="Member Functionssize()"></A><PRE>size_type 
<B>size</B>() const;</PRE>

<UL>
<P>Returns the number of elements.</P>
</UL>



<A NAME="Member Functionsswap()"></A><PRE>void 
<B>swap</B>(deque&lt;T,Allocator&gt;&amp; x);</PRE>

<UL>
<P>Exchanges self with <SAMP>x</SAMP>.</P>
</UL>


<A NAME="Non-member Functions"><H3>Non-member Functions</H3></A>


<A NAME="Non-member Functionsoperator==()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator==</B>(const deque&lt;T, Allocator&gt;&amp; x,
                 const deque&lt;T, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Equality operator. Returns <SAMP>true</SAMP> if <SAMP>x</SAMP> is the same as <SAMP>y</SAMP>.</P>
</UL>



<A NAME="Non-member Functionsoperator!=()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator!=</B>(const deque&lt;T, Allocator&gt;&amp; x,
                 const deque&lt;T, Allocator&gt;&amp; y);</PRE>

<UL>
<P> Returns <SAMP>true</SAMP> if <SAMP>x</SAMP> is not the same as <SAMP>y</SAMP>.</P>
</UL>



<A NAME="Non-member Functionsoperator&lt;()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator&lt;</B>(const deque&lt;T, Allocator&gt;&amp; x,
                const deque&lt;T, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the elements contained in <SAMP>x</SAMP> are lexicographically less than the elements contained in <SAMP>y</SAMP>.</P>
</UL>



<A NAME="Non-member Functionsoperator&gt;()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator&gt;</B>(const deque&lt;T, Allocator&gt;&amp; x,
                const deque&lt;T, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the elements contained in <SAMP>x</SAMP> are lexicographically greater than the elements contained in <SAMP>y</SAMP>.</P>
</UL>



<A NAME="Non-member Functionsoperator&lt;=()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator&lt;=</B>(const deque&lt;T, Allocator&gt;&amp; x,
                const deque&lt;T, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the elements contained in <SAMP>x</SAMP> are lexicographically less than or equal to the elements contained in <SAMP>y</SAMP>.</P>
</UL>



<A NAME="Non-member Functionsoperator&gt;=()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator&gt;=</B>(const deque&lt;T, Allocator&gt;&amp; x,
                const deque&lt;T, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the elements contained in <SAMP>x</SAMP> are lexicographically greater than or equal to the elements contained in <SAMP>y</SAMP>.</P>
</UL>



<PRE>template &lt;class T, class Allocator&gt;
bool <B>operator&lt;</B>(const deque&lt;T, Allocator&gt;&amp; x,
                const deque&lt;T, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the elements contained in <SAMP>x</SAMP> are lexicographically less than the elements contained in <SAMP>y</SAMP>.</P>
</UL>


<A NAME="Specialized Algorithms"><H3>Specialized Algorithms</H3></A>


<PRE>template &lt;class T, class Allocator&gt;
void <B>swap</B>(deque&lt;T, Allocator&gt;&amp; a, deque&lt;T, Allocator&gt;&amp; b);</PRE>

<UL>
<P>Swaps the contents of <SAMP>a</SAMP> and <SAMP>b</SAMP>.</P>
</UL>


<A NAME="Example"><H3>Example</H3></A>
<UL>
<PRE>//
// deque.cpp
//
 #include &lt;deque&gt;
 #include &lt;string&gt;
 #include &lt;iostream&gt;
 using namespace std;

 deque&lt;string, allocator&gt; deck_of_cards; 
 deque&lt;string, allocator&gt; current_hand;

 void initialize_cards(deque&lt;string, allocator&gt;&amp; cards) {
   cards.push_front("aceofspades");
   cards.push_front("kingofspades");
   cards.push_front("queenofspades");
   cards.push_front("jackofspades");
   cards.push_front("tenofspades");
   // etc.
 }

 template &lt;class It, class It2&gt; 
 void print_current_hand(It start, It2 end) 
 {
   while (start &lt; end) 
   cout &lt;&lt; *start++ &lt;&lt; endl;
 }


 template &lt;class It, class It2&gt;
 void deal_cards(It, It2 end) {
   for (int i=0;i&lt;5;i++) {
     current_hand.insert(current_hand.begin(),*end);
     deck_of_cards.erase(end++);
   }
 }

 void play_poker() {
   initialize_cards(deck_of_cards);
   deal_cards(current_hand.begin(),deck_of_cards.begin()); 
 }

 int main() 
 {
   play_poker();
   print_current_hand(current_hand.begin(),current_hand.end());
   return 0;
 }</PRE>

</UL>
<P><B>Program Output</B></P>
<UL>
<PRE>
aceofspades
kingofspades
queenofspades
jackofspades
tenofspades</PRE>

</UL>

<A NAME="Warnings"><H3>Warnings</H3></A>
<P>Member function templates are used in all containers in by the Standard Template Library. An example of this is the constructor for <B><I>deque&lt;T, Allocator&gt;</I></B>, which takes two templatized iterators: </P>
<UL>
<PRE>template &lt;class InputIterator&gt;
 deque (InputIterator, InputIterator);</PRE>

</UL>
<P><B><I>deque</I></B> also has an insert function of this type. These functions, when not restricted by compiler limitations, allow you to use any type of input iterator as arguments. For compilers that do not support this feature, substitute functions allow you to use an iterator obtained from the same type of container as the one you are constructing (or calling a member function on), or you can use a pointer to the type of element you have in the container. </P>
<P>For example, if your compiler does not support member function templates you can construct a <B><I>deque</I></B> in the following two ways: </P>
<UL>
<PRE>int intarray[10];
deque&lt;int&gt; first_deque(intarray, intarray + 10);
deque&lt;int&gt; second_deque(first_deque.begin(), 
                        first_deque.end());</PRE>

</UL>
<P>But not this way:</P>
<UL>
<PRE>deque&lt;long&gt; long_deque(first_deque.begin(), 
                                  first_deque.end());</PRE>

</UL>
<P>since the <SAMP>long_deque</SAMP> and <SAMP>first_deque</SAMP> are not the same type.</P>
<P>Additionally, many compilers do not support default template arguments. If your compiler is one of these, you always need to supply the <SAMP>Allocator</SAMP> template argument. For instance, you have to write:</P>
<P><SAMP>deque&lt;int, allocator&lt;int&gt; &gt;</SAMP></P>
<P>instead of:</P>
<P><SAMP>deque&lt;int&gt;</SAMP></P>
<P>If your compiler does not support namespaces, then you do not need the using declaration for <SAMP>std</SAMP>.</P>


<BR>
<HR>
<A HREF="cty_1366.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="dis_0186.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<BR>&copy;Copyright 1999, Rogue Wave Software, Inc.<BR>Send <A HREF="mailto:onlinedocs@roguewave.com">mail</A> to report errors or comment on the documentation.
<BR>
OEM Release</BODY></HTML>
