<HTML><HEAD><TITLE>list</TITLE></HEAD><BODY BGCOLOR=#FFFFFF>
<IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0><BR>
<A HREF="lim_2532.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="loc_6943.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><BR>

<H2>list</H2>
<PRE><HR>Container
<HR></PRE>
<UL>
<LI><A HREF="#Summary">Summary</A></LI>
<LI><A HREF="#memindex">Data Type and Member Function Indexes</A></LI>
<LI><A HREF="#Synopsis">Synopsis</A></LI>
<LI><A HREF="#Description">Description</A></LI>
<LI><A HREF="#Interface">Interface</A></LI>
<LI><A HREF="#Constructors">Constructors</A></LI>
<LI><A HREF="#Destructors">Destructors</A></LI>
<LI><A HREF="#Assignment Operators">Assignment Operators</A></LI>
<LI><A HREF="#Allocators">Allocators</A></LI>
<LI><A HREF="#Iterators">Iterators</A></LI>
<LI><A HREF="#Member Functions">Member Functions</A></LI>
<LI><A HREF="#Non-member Operators">Non-member Operators</A></LI>
<LI><A HREF="#Specialized Algorithms">Specialized Algorithms</A></LI>
<LI><A HREF="#Example">Example</A></LI>
<LI><A HREF="#Warnings">Warnings</A></LI>
<LI><A HREF="#See Also">See Also</A></LI>

</UL>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A sequence that supports bidirectional iterators.</P>
<A NAME="memindex"><H3>Data Type and Member Function Indexes<BR>(exclusive of constructors and destructors)</H3></A>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Member Functions</B></TD></TR><TR><TD VALIGN=top><A HREF="#Member Functionsassign()">assign()</A><BR>
 <A HREF="#Member Functionsback()">back()</A><BR>
 <A HREF="#Iteratorsbegin()">begin()</A><BR>
 <A HREF="#Member Functionsclear()">clear()</A><BR>
 <A HREF="#Member Functionsempty()">empty()</A><BR>
 <A HREF="#Iteratorsend()">end()</A><BR>
 <A HREF="#Member Functionserase()">erase()</A><BR>
 <A HREF="#Member Functionsfront()">front()</A><BR>
 <A HREF="#Allocatorsget_allocator()">get_allocator()</A><BR>
 <A HREF="#Member Functionsinsert()">insert()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Functionsmax_size()">max_size()</A><BR>
 <A HREF="#Member Functionsmerge()">merge()</A><BR>
 <A HREF="#Non-member Operatorsoperator!=()">operator!=()</A><BR>
 <A HREF="#Non-member Operatorsoperator&gt;()">operator&gt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&gt;=()">operator&gt;=()</A><BR>
 <A HREF="#Non-member Operatorsoperator&lt;()">operator&lt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&lt;=()">operator&lt;=()</A><BR>
 <A HREF="#Assignment Operatorsoperator=()">operator=()</A><BR>
 <A HREF="#Non-member Operatorsoperator==()">operator==()</A><BR>
 <A HREF="#Member Functionspop_back()">pop_back()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Functionspop_front()">pop_front()</A><BR>
 <A HREF="#Member Functionspush_back()">push_back()</A><BR>
 <A HREF="#Member Functionspush_front()">push_front()</A><BR>
 <A HREF="#Iteratorsrbegin()">rbegin()</A><BR>
 <A HREF="#Member Functionsremove()">remove()</A><BR>
 <A HREF="#Member Functionsremove_if()">remove_if()</A><BR>
 <A HREF="#Iteratorsrend()">rend()</A><BR>
 <A HREF="#Member Functionsresize()">resize()</A><BR>
 <A HREF="#Member Functionsreverse()">reverse()</A><BR>
 <A HREF="#Member Functionssize()">size()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Functionssort()">sort()</A><BR>
 <A HREF="#Member Functionssplice()">splice()</A><BR>
 <A HREF="#Member Functionsswap()">swap()</A><BR>
 <A HREF="#Member Functionsunique()">unique()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>
<PRE>#include &lt;list&gt;
template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
class <B>list</B>;</PRE>

</PRE>

<A NAME="Description"><H3>Description</H3></A>
<P><B><I>list&lt;T,Allocator&gt;</I></B> is a type of sequence that supports bidirectional iterators. A <B><I>list&lt;T,Allocator&gt;</I></B> allows constant time insert and erase operations anywhere within the sequence, with storage management handled automatically. Constant time random access is not supported. </P>
<P>Any type used for the template parameter <SAMP>T</SAMP> must include the following (where <SAMP>T</SAMP> is the type, <SAMP>t</SAMP> is a <SAMP>value</SAMP> of <SAMP>T</SAMP> and <SAMP>u</SAMP> is a <SAMP>const</SAMP> <SAMP>value</SAMP> of <SAMP>T</SAMP>): </P>
<TABLE>
<TR><TD VALIGN=top>Copy constructors  </TD>
<TD><SAMP>T(t)</SAMP> and <SAMP>T(u)</SAMP></TD></TR>
<TR><TD VALIGN=top>Destructor  </TD>
<TD><SAMP>t.~T()</SAMP></TD></TR>
<TR><TD VALIGN=top>Address of  </TD>
<TD><SAMP>&amp;t</SAMP> and <SAMP>&amp;u</SAMP> yielding <SAMP>T*</SAMP> and <SAMP>const T*</SAMP> respectively</TD></TR>
<TR><TD VALIGN=top>Assignment  </TD>
<TD><SAMP>t = a</SAMP> where <SAMP>a</SAMP> is a (possibly <SAMP>const</SAMP>) value of <SAMP>T</SAMP></TD></TR>
</TABLE>

<A NAME="Interface"><H3>Interface</H3></A>
<UL>
<PRE>template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
 class list {

public:

// typedefs

   class iterator;
   class const_iterator;
   typedef typename
           Allocator::reference        reference;
   typedef typename
           Allocator::const_reference  const_reference;
   typedef typename
           Allocator::size_type        size_type;
   typedef typename
           Allocator::difference_type  difference_type;
   typedef T value_type;
   typedef Allocator allocator_type;
</PRE>

</UL>
<PRE>
<PRE>   typedef typename std::reverse_iterator&lt;iterator&gt;
                         reverse_iterator;
   typedef typename std::reverse_iterator&lt;const_iterator&gt;
                         const_reverse_iterator;</PRE>

<UL>
<PRE>
// Construct/Copy/Destroy

   explicit list (const Allocator&amp; = Allocator());
   explicit list (size_type);
   list (size_type, const T&amp;, const Allocator&amp; =
         Allocator())
   template &lt;class InputIterator&gt;
   list (InputIterator, InputIterator, 
         const Allocator&amp; = Allocator());
   list(const list&lt;T, Allocator&gt;&amp; x);
   ~list();
   list&lt;T,Allocator&gt;&amp; operator= (const list&lt;T,Allocator&gt;&amp;);
   template &lt;class InputIterator&gt;
    void assign (InputIterator, InputIterator);
   void assign (size_type n, const T&amp;);

   allocator_type get allocator () const;

// Iterators

   iterator begin ();
   const_iterator begin () const;
   iterator end ();
   const_iterator end () const;
   reverse_iterator rbegin ();
   const_reverse_iterator rbegin () const;
   reverse_iterator rend ();
   const_reverse_iterator rend () const;

// Capacity

   bool empty () const;
   size_type size () const;
   size_type max_size () const;
   void resize (size_type);
   void resize (size_type, T);

// Element Access

   reference front ();
   const_reference front () const;
   reference back ();
   const_reference back () const;

// Modifiers

   void push_front (const T&amp;);
   void pop_front ();
   void push_back (const T&amp;);
   void pop_back ();

   iterator insert (iterator, const T&amp;);
   void insert (iterator, size_type, const T&amp;);
   template &lt;class InputIterator&gt;
    void insert (iterator, InputIterator, InputIterator);

   iterator erase (iterator);
   iterator erase (iterator, iterator);

   void swap (list&lt;T, Allocator&gt;&amp;);
   void clear ();

// Special mutative operations on list

   void splice (iterator, list&lt;T, Allocator&gt;&amp;);
   void splice (iterator, list&lt;T, Allocator&gt;&amp;, iterator);
   void splice (iterator, list&lt;T, Allocator&gt;&amp;, iterator,
                iterator);

   void remove (const T&amp;);
   template &lt;class Predicate&gt;
    void remove_if (Predicate);

   void unique ();
   template &lt;class BinaryPredicate&gt;
    void unique (BinaryPredicate);

   void merge (list&lt;T, Allocator&gt;&amp;);
   template &lt;class Compare&gt;
    void merge (list&lt;T, Allocator&gt;&amp;, Compare);

   void sort ();
   template &lt;class Compare&gt;
    void sort (Compare);

   void reverse();
};



// Non-member List Operators

template &lt;class T, class Allocator&gt;
 bool <B>operator==</B> (const list&lt;T, Allocator&gt;&amp;, 
                  const list&lt;T, Allocator&gt;&amp;);

template &lt;class T, class Allocator&gt;
 bool <B>operator!=</B> (const list&lt;T, Allocator&gt;&amp;, 
                  const list&lt;T, Allocator&gt;&amp;);

template &lt;class T, class Allocator&gt;
 bool <B>operator&lt;</B> (const list&lt;T, Allocator&gt;&amp;,
                 const list&lt;T, Allocator&gt;&amp;);

template &lt;class T, class Allocator&gt;
 bool <B>operator&gt;</B> (const list&lt;T, Allocator&gt;&amp;,
                 const list&lt;T, Allocator&gt;&amp;);

template &lt;class T, class Allocator&gt;
 bool <B>operator&lt;=</B> (const list&lt;T, Allocator&gt;&amp;,
                 const list&lt;T, Allocator&gt;&amp;);

template &lt;class T, class Allocator&gt;
 bool <B>operator&gt;=</B> (const list&lt;T, Allocator&gt;&amp;,
                 const list&lt;T, Allocator&gt;&amp;);

// Specialized Algorithms

template &lt;class T, class Allocator&gt;
void swap (list&lt;T,Allocator&gt;&amp;, list&lt;T, Allocator&gt;&amp;);</PRE>

</UL>
</PRE>

<A NAME="Constructors"><H3>Constructors</H3></A>


<PRE>explicit <B>list</B>(const Allocator&amp; alloc = Allocator());</PRE>

<UL>
<P>Creates a list of zero elements. The list uses the allocator                <SAMP>alloc</SAMP> for all storage management.</P>
</UL>



<PRE>explicit <B>list</B>(size_type n);</PRE>

<UL>
<P>Creates a list of length <SAMP>n</SAMP>, containing <SAMP>n</SAMP> copies of the default value for type <SAMP>T</SAMP>. <SAMP>T</SAMP> must have a default constructor. The list uses the allocator Allocator() for all storage management. </P>
</UL>



<PRE><B>list</B>(size_type n, const T&amp; value, 
      const Allocator&amp; alloc = Allocator());</PRE>

<UL>
<P>Creates a list of length <SAMP>n</SAMP>, containing <SAMP>n</SAMP> copies of <SAMP>value</SAMP>. The list uses the allocator <SAMP>alloc</SAMP> for all storage management. </P>
</UL>



<PRE>template &lt;class InputIterator&gt;
<B>list</B>(InputIterator first, InputIterator last,
      const Allocator&amp; alloc = Allocator()); </PRE>

<UL>
<P>Creates a list of length <SAMP>last - first</SAMP>, filled with all values obtained by dereferencing the <SAMP>InputIterators</SAMP> on the range <SAMP>[first, last)</SAMP>. The list uses the allocator <SAMP>alloc</SAMP> for all storage management.</P>
</UL>



<PRE><B>list</B>(const list&lt;T, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Creates a copy of <SAMP>x</SAMP>.</P>
</UL>


<A NAME="Destructors"><H3>Destructors</H3></A>


<PRE><B>~list</B>();</PRE>

<UL>
<P>Releases any allocated memory for this list.</P>
</UL>


<A NAME="Assignment Operators"><H3>Assignment Operators</H3></A>


<A NAME="Assignment Operatorsoperator=()"></A><PRE>list&lt;T, Allocator&gt;&amp; 
<B>operator=</B>(const list&lt;T, Allocator&gt;&amp; x)</PRE>

<UL>
<P>Erases all elements in self, then inserts into self a copy of each element in <SAMP>x</SAMP>. Returns a reference to <SAMP>*this</SAMP>.</P>
</UL>


<A NAME="Allocators"><H3>Allocators</H3></A>


<A NAME="Allocatorsget_allocator()"></A><PRE>allocator_type 
<B>get_allocator</B>() const;</PRE>

<UL>
<P>Returns a copy of the allocator used by self for storage management.</P>
</UL>


<A NAME="Iterators"><H3>Iterators</H3></A>


<A NAME="Iteratorsbegin()"></A><PRE>iterator 
<B>begin</B>();</PRE>

<UL>
<P>Returns a bidirectional iterator that points to the first element.</P>
</UL>



<PRE>const_iterator 
<B>begin</B>() const;</PRE>

<UL>
<P>Returns a constant bidirectional iterator that points to the first element.</P>
</UL>



<A NAME="Iteratorsend()"></A><PRE>iterator 
<B>end</B>();</PRE>

<UL>
<P>Returns a bidirectional iterator that points to the past-the-end value.</P>
</UL>



<PRE>const_iterator 
<B>end</B>() const;</PRE>

<UL>
<P>Returns a constant bidirectional iterator that points to the past-the-end value.</P>
</UL>



<A NAME="Iteratorsrbegin()"></A><PRE>reverse_iterator 
<B>rbegin</B>();</PRE>

<UL>
<P>Returns a bidirectional iterator that points to the past-the-end value.</P>
</UL>



<PRE>const_reverse_iterator
<B>rbegin</B>() const;</PRE>

<UL>
<P>Returns a constant bidirectional iterator that points to the past-the-end value.</P>
</UL>



<A NAME="Iteratorsrend()"></A><PRE>reverse_iterator 
<B>rend</B>();</PRE>

<UL>
<P>Returns a bidirectional iterator that points to the first element.</P>
</UL>



<PRE>const_reverse_iterator 
<B>rend</B>() const;</PRE>

<UL>
<P>Returns a constant bidirectional iterator that points to the first element.</P>
</UL>


<A NAME="Member Functions"><H3>Member Functions</H3></A>


<PRE>template &lt;class InputIterator&gt;
<A NAME="Member Functionsassign()"></A>void 
<B>assign</B>(InputIterator first, InputIterator last);</PRE>

<UL>
<P>Erases all elements contained in self, then inserts new elements from the range <SAMP>[first, last)</SAMP>.</P>
</UL>



<PRE>void 
<B>assign</B>(size_type n, const T&amp; t);</PRE>

<UL>
<P>Erases all elements contained in self, then inserts <SAMP>n</SAMP> instances of the <SAMP>value</SAMP> of <SAMP>t.</SAMP></P>
</UL>



<A NAME="Member Functionsback()"></A><PRE>reference 
<B>back</B>();</PRE>

<UL>
<P>Returns a <SAMP>reference</SAMP> to the last element.</P>
</UL>



<PRE>const_reference 
<B>back</B>() const;</PRE>

<UL>
<P>Returns a constant reference to the last element.</P>
</UL>



<A NAME="Member Functionsclear()"></A><PRE>void
<B>clear</B>();</PRE>

<UL>
<P>Erases all elements from the list.</P>
</UL>



<A NAME="Member Functionsempty()"></A><PRE>bool 
<B>empty</B>() const;</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the <SAMP>size</SAMP> is zero.</P>
</UL>



<A NAME="Member Functionserase()"></A><PRE>iterator
<B>erase</B>(iterator position);</PRE>

<UL>
<P>Removes the element pointed to by <SAMP>position</SAMP>. Returns an iterator pointing to the element following the deleted element, or <SAMP>end()</SAMP> if the deleted item was the last one in this list.</P>
</UL>



<PRE>iterator
<B>erase</B>(iterator first, iterator last);</PRE>

<UL>
<P>Removes the elements in the range (<SAMP>first, last</SAMP>). Returns an iterator pointing to the element following the element following the last deleted element, or <SAMP>end()</SAMP> if there were no elements after the deleted range.</P>
</UL>



<A NAME="Member Functionsfront()"></A><PRE>reference 
<B>front</B>();</PRE>

<UL>
<P>Returns a reference to the first element.</P>
</UL>



<PRE>const_reference 
<B>front</B>() const;</PRE>

<UL>
<P>Returns a constant reference to the first element.</P>
</UL>



<A NAME="Member Functionsinsert()"></A><PRE>iterator 
<B>insert</B>(iterator position, const T&amp; x);</PRE>

<UL>
<P>Inserts <SAMP>x</SAMP> before <SAMP>position</SAMP>. Returns an iterator that points to the inserted <SAMP>x</SAMP>.</P>
</UL>



<PRE>void 
<B>insert</B>(iterator position, size_type n, const T&amp; x);</PRE>

<UL>
<P>Inserts <SAMP>n</SAMP> copies of <SAMP>x</SAMP> before <SAMP>position</SAMP>.</P>
</UL>



<PRE>template &lt;class InputIterator&gt;
void 
<B>insert</B>(iterator position, InputIterator first,
        InputIterator last);</PRE>

<UL>
<P>Inserts copies of the elements in the range <SAMP>[first, last)</SAMP> before <SAMP>position</SAMP>.</P>
</UL>



<A NAME="Member Functionsmax_size()"></A><PRE>size_type
<B>max_size</B>() const;</PRE>

<UL>
<P>Returns <SAMP>size()</SAMP> of the largest possible list.</P>
</UL>



<A NAME="Member Functionsmerge()"></A><PRE>void 
<B>merge</B>(list&lt;T, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Merges a sorted <SAMP>x</SAMP> with a sorted self using <SAMP>operator&lt;</SAMP>. For equal elements in the two lists, elements from self always precede the elements from <SAMP>x</SAMP>. The <SAMP>merge</SAMP> function leaves <SAMP>x</SAMP> empty.</P>
</UL>



<PRE>template &lt;class Compare&gt;
void 
<B>merge</B>(list&lt;T, Allocator&gt;&amp; x, Compare comp);</PRE>

<UL>
<P>Merges a sorted <SAMP>x</SAMP> with sorted self using a compare function object, <SAMP>comp</SAMP>. For identical elements in the two lists, elements from self always precede the elements from <SAMP>x</SAMP>. The <SAMP>merge</SAMP> function leaves <SAMP>x</SAMP> empty.</P>
</UL>



<A NAME="Member Functionspop_back()"></A><PRE>void 
<B>pop_back</B>();</PRE>

<UL>
<P>Removes the last element.</P>
</UL>



<A NAME="Member Functionspop_front()"></A><PRE>void 
<B>pop_front</B>();</PRE>

<UL>
<P>Removes the first element.</P>
</UL>



<A NAME="Member Functionspush_back()"></A><PRE>void 
<B>push_back</B>(const T&amp; x);</PRE>

<UL>
<P>Appends a copy of <SAMP>x</SAMP> to the end of the list.</P>
</UL>



<A NAME="Member Functionspush_front()"></A><PRE>void
<B>push_front</B>(const T&amp; x);</PRE>

<UL>
<P>Appends a copy of <SAMP>x</SAMP> to the front of the list.</P>
</UL>



<A NAME="Member Functionsremove()"></A><PRE>void 
<B>remove</B>(const T&amp; value);
template &lt;class Predicate&gt;
<A NAME="Member Functionsremove_if()"></A>void 
<B>remove_if</B>(Predicate pred);</PRE>

<UL>
<P>Removes all elements in the list referenced by the list iterator <SAMP>i</SAMP> for which <SAMP>*i == value</SAMP> or <SAMP>pred(*i) == true</SAMP>, whichever is applicable. This is a stable operation. The relative order of list items that are not removed is preserved.</P>
</UL>



<A NAME="Member Functionsresize()"></A><PRE>void 
<B>resize</B>(size_type sz);</PRE>

<UL>
<P>Alters the size of self. If the new size ( <SAMP>sz</SAMP> ) is greater than the current size, <SAMP>sz</SAMP>-<SAMP>size()</SAMP> copies of the default value of type <SAMP>T</SAMP> are inserted at the end of the list. If the new size is smaller than the current capacity, then the list is truncated by erasing <SAMP>size()-sz</SAMP> elements off the end. Otherwise, no action is taken. Type <SAMP>T</SAMP> must have a default constructor.</P>
</UL>



<PRE>void 
<B>resize</B>(size_type sz, T c);</PRE>

<UL>
<P>Alters the size of self. If the new size ( <SAMP>sz</SAMP> ) is greater than the current size, <SAMP>sz</SAMP>-<SAMP>size() c</SAMP>'s are inserted at the end of the list. If the new size is smaller than the current capacity, then the list is truncated by erasing <SAMP>size()-sz</SAMP> elements off the end. Otherwise, no action is taken. </P>
</UL>



<A NAME="Member Functionsreverse()"></A><PRE>void 
<B>reverse</B>();</PRE>

<UL>
<P>Reverses the order of the elements.</P>
</UL>



<A NAME="Member Functionssize()"></A><PRE>size_type 
<B>size</B>() const;</PRE>

<UL>
<P>Returns the number of elements.</P>
</UL>



<A NAME="Member Functionssort()"></A><PRE>void 
<B>sort</B>();</PRE>

<UL>
<P>Sorts self according to the <SAMP>operator&lt;</SAMP>. <SAMP>sort</SAMP> maintains the relative order of equal elements.</P>
</UL>



<PRE>template &lt;class Compare&gt;
void 
<B>sort</B>(Compare comp);</PRE>

<UL>
<P>Sorts self according to a comparison function object, <SAMP>comp</SAMP>. This is also a stable sort.   </P>
</UL>



<A NAME="Member Functionssplice()"></A><PRE>void 
<B>splice</B>(iterator position, list&lt;T, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Inserts <SAMP>x</SAMP> before <SAMP>position</SAMP>, leaving <SAMP>x</SAMP> empty.</P>
</UL>



<PRE>void 
<B>splice</B>(iterator position, list&lt;T, Allocator&gt;&amp; x, 
        iterator i);</PRE>

<UL>
<P>Moves the elements pointed to by iterator <SAMP>i</SAMP> in <SAMP>x</SAMP> to self, inserting it before <SAMP>position</SAMP>. The element is removed from <SAMP>x</SAMP>.</P>
</UL>



<PRE>void 
<B>splice</B>(iterator position, list&lt;T, Allocator &gt;&amp; x,
        iterator first, iterator last);</PRE>

<UL>
<P>Moves the elements in the range <SAMP>[first, last)</SAMP> in <SAMP>x</SAMP> to self, inserting them before <SAMP>position</SAMP>. The elements in the range <SAMP>[first, last)</SAMP> are removed from <SAMP>x</SAMP>.</P>
</UL>



<A NAME="Member Functionsswap()"></A><PRE>void
<B>swap</B>(list &lt;T, Allocator&gt;&amp; x);</PRE>

<UL>
<P>Exchanges self with <SAMP>x</SAMP>.</P>
</UL>



<A NAME="Member Functionsunique()"></A><PRE>void 
<B>unique</B>();</PRE>

<UL>
<P>Erases copies of consecutive repeated elements leaving the first occurrence.</P>
</UL>



<PRE>template &lt;class BinaryPredicate&gt;
void 
<B>unique</B>(BinaryPredicate binary_pred);</PRE>

<UL>
<P>Erases consecutive elements matching a <SAMP>true</SAMP> condition of the <SAMP>binary_pred</SAMP>. The first occurrence is not removed.</P>
</UL>


<A NAME="Non-member Operators"><H3>Non-member Operators</H3></A>


<A NAME="Non-member Operatorsoperator==()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator==</B>(const list&lt;T, Allocator&gt;&amp; x,
                 const list&lt;T, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if <SAMP>x</SAMP> is the same as <SAMP>y</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator!=()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator!=</B>(const list&lt;T, Allocator&gt;&amp; x,
                 const list&lt;T, Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns !<SAMP>(x==y)</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&lt;()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator&lt;</B>(const list&lt;T, Allocator&gt;&amp; x,
                const list&lt;T,Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the sequence defined by the elements contained in <SAMP>x</SAMP> is lexicographically less than the sequence defined by the elements contained in <SAMP>y</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&gt;()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator&gt;</B>(const list&lt;T, Allocator&gt;&amp; x,
                const list&lt;T,Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>y &lt; x</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&lt;=()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator&lt;=</B>(const list&lt;T, Allocator&gt;&amp; x,
                const list&lt;T,Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns !<SAMP>(y &lt; x)</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&gt;=()"></A><PRE>template &lt;class T, class Allocator&gt;
bool <B>operator&gt;=</B>(const list&lt;T, Allocator&gt;&amp; x,
                const list&lt;T,Allocator&gt;&amp; y);</PRE>

<UL>
<P>Returns !<SAMP>(x &lt; y)</SAMP>.</P>
</UL>


<A NAME="Specialized Algorithms"><H3>Specialized Algorithms</H3></A>


<PRE>template &lt;class T, class Allocator&gt;
void <B>swap</B>(list&lt;T, Allocator&gt;&amp; a, list&lt;T, Allocator&gt;&amp; b);</PRE>

<UL>
<P> Swaps the contents of <SAMP>a</SAMP> and <SAMP>b</SAMP>.</P>
</UL>


<A NAME="Example"><H3>Example</H3></A>
<UL>
<PRE>//
// list.cpp
//
 #include &lt;list&gt;
 #include &lt;string&gt;
 #include &lt;iostream&gt;
 using namespace std;
 // Print out a list of strings
 ostream&amp; operator&lt;&lt;(ostream&amp; out, const list&lt;string&gt;&amp; l)
 {

   copy(l.begin(), l.end(), 
        ostream_iterator&lt;string,char&gt;(cout," "));
   return out;
 }
 int main(void)
 {

   // create a list of critters
   list&lt;string&gt; critters;
   int i;

   // insert several critters 
   critters.insert(critters.begin(),"antelope");
   critters.insert(critters.begin(),"bear");
   critters.insert(critters.begin(),"cat");

   // print out the list
   cout &lt;&lt; critters &lt;&lt; endl;
   
   // Change cat to cougar
   *find(critters.begin(),critters.end(),"cat") = "cougar";
   cout &lt;&lt; critters &lt;&lt; endl;

   // put a zebra at the beginning 
   // an ocelot ahead of antelope
   // and a rat at the end
   critters.push_front("zebra");
   critters.insert(find(critters.begin(),critters.end(),
                   "antelope"),"ocelot");
   critters.push_back("rat");
   cout &lt;&lt; critters &lt;&lt; endl;

   // sort the list (Use list's sort function since the 
   // generic algorithm requires a random access iterator 
   // and list only provides bidirectional)
   critters.sort();
   cout &lt;&lt; critters &lt;&lt; endl;

   // now let's erase half of the critters
   int half = critters.size() &gt;&gt; 1;
   for(i = 0; i &lt; half; ++i) {
     critters.erase(critters.begin());
   }
   cout &lt;&lt; critters &lt;&lt; endl;
   return 0;
 }


</PRE>

</UL>
<P><B>Program Output</B></P>
<UL>
<PRE>
cat bear antelope
cougar bear antelope
zebra cougar bear ocelot antelope rat
antelope bear cougar ocelot rat zebra
ocelot rat zebra</PRE>

</UL>

<A NAME="Warnings"><H3>Warnings</H3></A>
<P>Member function templates are used in all containers included in the Standard Template Library. An example of this feature is the constructor for <B><I>list&lt;T, Allocator&gt;</I></B> that takes two templatized iterators:</P>
<UL>
<PRE>template &lt;class InputIterator&gt;
list (InputIterator, InputIterator, 
      const Allocator&amp; = Allocator());</PRE>

</UL>
<P><B><I>list</I></B> also has an <SAMP>insert</SAMP> function of this type. These functions, when not restricted by compiler limitations, allow you to use any type of input iterator as arguments. For compilers that do not support this feature, substitute functions allow you to use an iterator obtained from the same type of container as the one you are constructing (or calling a member function on), or you can use a pointer to the type of element you have in the container.</P>
<P>For example, if your compiler does not support member function templates, you can construct a list in the following two ways:</P>
<UL>
<PRE>int intarray[10];
list&lt;int&gt; first_list(intarray,intarray + 10);
list&lt;int&gt; second_list(first_list.begin(),first_list.end());</PRE>

</UL>
<P>But not this way:</P>
<UL>
<PRE>list&lt;long&gt; long_list(first_list.begin(),first_list.end());</PRE>

</UL>
<P>since the <SAMP>long_list</SAMP> and <SAMP>first_list</SAMP> are not the same type.</P>
<P>Additionally, <B><I>list</I></B> includes a <SAMP>merge</SAMP> function of this type. </P>
<UL>
<PRE>template &lt;class Compare&gt; void merge (list&lt;T, Allocator&gt;&amp;,
  Compare);</PRE>

</UL>
<P>This function allows you to specify a compare function object to be used in merging two lists. In this case, a substitute function is not included with the merge that uses the <SAMP>operator&lt;</SAMP> as the default. Thus, if your compiler does not support member function templates, all list merges use <SAMP>operator&lt;</SAMP>.</P>
<P>Also, many compilers do not support default template arguments. If your compiler is one of these, you always need to supply the <SAMP>Allocator</SAMP> template argument. For instance, you have to write: </P>
<P><SAMP>list&lt;int, allocator&lt;int&gt; &gt;</SAMP></P>
<P>instead of:</P>
<P><SAMP>list&lt;int&gt;</SAMP></P>
<P>If your compiler does not support namespaces, then you do not need the using declaration for <SAMP>std</SAMP>.</P>

<A NAME="See Also"><H3>See Also</H3></A>
<P><B><I><A HREF="all_7029.htm">allocator</A></I></B>, <B><I><A HREF="Con_2487.htm">Containers</A></I></B>, <B><I><A HREF="Ite_5295.htm">Iterators</A></I></B></P>


<BR>
<HR>
<A HREF="lim_2532.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="loc_6943.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<BR>&copy;Copyright 1999, Rogue Wave Software, Inc.<BR>Send <A HREF="mailto:onlinedocs@roguewave.com">mail</A> to report errors or comment on the documentation.
<BR>
OEM Release</BODY></HTML>
