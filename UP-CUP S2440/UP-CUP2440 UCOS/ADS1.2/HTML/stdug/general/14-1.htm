<HTML><HEAD><TITLE>14.1 Overview</TITLE></HEAD>
<BODY BGCOLOR=#FFFFFF>
<A HREF="../index.htm"><IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0></A><BR>
<A HREF="14.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="14-2.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<H2>14.1 Overview</H2>
<A NAME="idx338"><!></A>
<P>In this section we describe the generic algorithms in the Standard C++ Library that are specific to ordered collections. These algorithms are summarized in <A HREF="#Table 20">Table 20</A>:</P>
<TABLE BORDER CELLPADDING=3 CELLSPACING=3>
<H4><A NAME="Table 20">Table 20 -- Generic algorithms specific to ordered collections</A> </H4><tr><td valign=top><B>Algorithm</B><td valign=top><B>Purpose</B>&nbsp;
<tr><td valign=top colspan=2 rowspan=1>
<B><I>Sorting algorithms</I></B><BR>

<tr><td valign=top>
<SAMP>sort()</SAMP><BR>
<td valign=top>
Rearranges sequence, places in order<BR>

<tr><td valign=top>
<SAMP>stable_sort()</SAMP><BR>
<td valign=top>
Sorts, retaining original order of equal elements<BR>

<tr><td valign=top>
<SAMP>partial_sort()</SAMP><BR>
<td valign=top>
Sorts only part of sequence<BR>

<tr><td valign=top>
<SAMP>partial_sort_copy()</SAMP><BR>
<td valign=top>
Partial sorts into copy<BR>

<tr><td valign=top colspan=2 rowspan=1>
<B><I>Nth largest element algorithm</I></B><BR>

<tr><td valign=top>
<SAMP>nth_element()</SAMP><BR>
<td valign=top>
Locates nth largest element<BR>

<tr><td valign=top colspan=2 rowspan=1>
<B><I>Binary search algorithms</I></B><BR>

<tr><td valign=top>
<SAMP>binary_search()</SAMP><BR>
<td valign=top>
Searches, returning boolean<BR>

<tr><td valign=top>
<SAMP>lower_bound()</SAMP><BR>
<td valign=top>
Searches, returning first position<BR>

<tr><td valign=top>
<SAMP>upper_bound()</SAMP><BR>
<td valign=top>
Searches, returning last position<BR>

<tr><td valign=top>
<SAMP>equal_range()</SAMP><BR>
<td valign=top>
Searches, returning both positions<BR>

<tr><td valign=top colspan=2 rowspan=1>
<B><I>Merge ordered sequences algorithm</I></B><BR>

<tr><td valign=top>
<SAMP>merge()</SAMP><BR>
<td valign=top>
Combines two ordered sequences<BR>

<tr><td valign=top colspan=2 rowspan=1>
<B><I>Set operations algoithms</I></B><BR>

<tr><td valign=top>
<SAMP>set_union()</SAMP><BR>
<td valign=top>
Forms union of two sets<BR>

<tr><td valign=top>
<SAMP>set_intersection()</SAMP><BR>
<td valign=top>
Forms intersection of two sets<BR>

<tr><td valign=top>
<SAMP>set_difference()</SAMP><BR>
<td valign=top>
Forms difference of two sets<BR>

<tr><td valign=top>
<SAMP>set_symmetric_difference()</SAMP><BR>
<td valign=top>
Forms symmetric difference of two sets<BR>

<tr><td valign=top>
<SAMP>includes()</SAMP><BR>
<td valign=top>
Sees if one set is a subset of another<BR>

<tr><td valign=top colspan=2 rowspan=1>
<B><I>Heap operations algorithms</I></B><BR>

<tr><td valign=top>
<SAMP>make_heap()</SAMP><BR>
<td valign=top>
Turns a sequence into a heap<BR>

<tr><td valign=top>
<SAMP>push_heap()</SAMP><BR>
<td valign=top>
Adds a new value to the heap<BR>

<tr><td valign=top>
<SAMP>pop_heap()</SAMP><BR>
<td valign=top>
Removes largest value from the heap<BR>

<tr><td valign=top>
<SAMP>sort_heap()</SAMP><BR>
<td valign=top>
Turns heap into sorted collection<BR>


</TABLE>


</P>
<P>Ordered collections can be created using the Standard C++ Library in a variety of ways. For example:</P>
<UL>
<LI><P>The containers <B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B>, <B><I><A HREF="../../stdref/mul_0958.htm">multiset</A></I></B>, <B><I><A HREF="../../stdref/map_8018.htm">map</A></I></B>, and <B><I><A HREF="../../stdref/mul_8396.htm">multimap</A></I></B> are ordered collections by definition.</P>
</LI>
<LI><P>A <B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B> can be ordered by invoking the <SAMP>sort()</SAMP> member function.</P>
</LI>
<LI><P>A <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B>, <B><I><A HREF="../../stdref/deq_4164.htm">deque</A></I></B>, or ordinary C++ array can be ordered by using one of the sorting algorithms described in <A HREF="14-2.htm">Section 14.2</A>.</P>
</LI>
</UL>
<P>Like the generic algorithms described in <A HREF="13.htm">Section 13</A>, the algorithms described here are not specific to any particular container class. This means that they can be used with a wide variety of types. However, many of them do require the use of random-access <B><I><A HREF="../../stdref/ite_5554.htm">iterator</A></I></B>s. For this reason they are most easily used with <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B>s, <B><I><A HREF="../../stdref/deq_4164.htm">deque</A></I></B>s, or ordinary arrays.</P>
<P>Almost all the algorithms described in this section have two versions. The first version uses the <SAMP>less than</SAMP> operator <SAMP>&lt;</SAMP> for comparisons appropriate to the container element type. The second, and more general, version uses an explicit comparison function object, which we will write as <SAMP>Compare</SAMP>. This function object must be a binary predicate (see <A HREF="3-2.htm">Section 3.2</A>). Since this argument is optional, we will write it within square brackets in the description of the argument types.</P>
<A NAME="idx339"><!></A>
<P>A sequence is considered <I>ordered</I> if for every valid or <I>denotable</I> iterator <SAMP>i</SAMP> with a denotable successor <SAMP>j</SAMP>, the comparison <SAMP>Compare(*j, *i)</SAMP> is <SAMP>false</SAMP>. Note that this does not necessarily imply that <SAMP>Compare(*i, *j)</SAMP> is <SAMP>true</SAMP>. It is assumed that the relation imposed by <SAMP>Compare</SAMP> is transitive, and induces a total ordering on the values.</P>
<P>In the descriptions that follow, two values <SAMP>x</SAMP> and <SAMP>y</SAMP> are said to be equivalent if both <SAMP>Compare(x, y)</SAMP> and <SAMP>Compare(y, x)</SAMP> are <SAMP>false</SAMP>. Note that this need not imply that <SAMP>x == y</SAMP>.</P>

<A NAME="1411"><H3>14.1.1 Include Files</H3></A>
<A NAME="idx340"><!></A>
<P>As with the algorithms described in <A HREF="13.htm">Chapter 13</A>, before you can use any of these algorithms in a program you must include the <SAMP>algorithm</SAMP> header file:</P>
<UL>
<PRE>
# include &lt;algorithm&gt;</PRE>
</UL>

<HR>
<A HREF="14.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="14-2.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><P>OEM Edition, &copy;Copyright 1999, Rogue Wave Software, Inc.<BR><A HREF="contact.htm">Contact</A> Rogue Wave about documentation or support issues.</P>
</BODY></HTML>
