<HTML><HEAD><TITLE>14.4 Binary Search</TITLE></HEAD>
<BODY BGCOLOR=#FFFFFF>
<A HREF="../index.htm"><IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0></A><BR>
<A HREF="14-3.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="14-5.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<H2>14.4 Binary Search</H2>
<A NAME="idx349"><!></A>
<P>The Standard C++ Library provides a number of different variations on binary search algorithms.   All perform only approximately <SAMP>log n</SAMP> comparisons, where <SAMP>n</SAMP> is the number of elements in the range described by the arguments. The algorithms work best with random access <B><I><A HREF="../../stdref/ite_5554.htm">iterator</A></I></B>s, like those generated by <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B>s or <B><I><A HREF="../../stdref/deq_4164.htm">deque</A></I></B>s, when they also perform approximately <SAMP>log n</SAMP> operations in total. However, they also work with non-random access <B><I>iterator</I></B>s, like those generated by <B><I><A HREF="../../stdref/lis_3222.htm">list</A></I></B>s, in which case they perform a linear number of steps. Although legal, it is not necessary to perform a binary search on a <B><I><A HREF="../../stdref/set_1649.htm">set</A></I></B> or <B><I><A HREF="../../stdref/mul_0958.htm">multiset</A></I></B> data structure, since those container classes provide their own search methods, which are more efficient.</P>
<A NAME="idx350"><!></A>
<P>The generic algorithm <SAMP>binary_search()</SAMP> returns <SAMP>true</SAMP> if the sequence contains a value that is equivalent to the argument. Recall that to be equivalent means that both <SAMP>Compare(value, arg)</SAMP> and <SAMP>Compare(arg, value)</SAMP> are <SAMP>false</SAMP>. The algorithm is declared as follows:</P>
<UL>
<PRE>
bool binary_search (ForwardIterator first, ForwardIterator last, 
      const T &amp; value [, Compare ] );</PRE>
</UL>
<P>In other situations it is important to know the position of the matching value. This information is returned by a collection of algorithms, defined as follows:</P>
<UL>
<PRE>
ForwardIterator last, const T&amp; value [, Compare ] );

ForwardIterator upper_bound (ForwardIterator first, 
   ForwardIterator last, const T&amp; value [, Compare ] );

pair&lt;ForwardIterator, ForwardIterator&gt; equal_range
   (ForwardIterator first, ForwardIterator last,
      const T&amp; value [, Compare ] );</PRE>
</UL>
<A NAME="idx351"><!></A>
<P>The algorithm <SAMP>lower_bound()</SAMP> returns, as an <B><I><A HREF="../../stdref/ite_5554.htm">iterator</A></I></B>, the first position into which the argument could be inserted without violating the ordering, whereas the algorithm <SAMP>upper_bound()</SAMP> finds the last such position. These match only when the element is not currently found in the sequence. Both can be executed together in the algorithm <SAMP>equal_range()</SAMP>, which returns a pair of <B><I>iterator</I></B>s.</P>
<P>Our example program shows these functions being used with a <B><I><A HREF="../../stdref/vec_0251.htm">vector</A></I></B> of random integers.</P>
<UL>
<PRE>
void binary_search_example ()</PRE>
<A NAME="idx352"><!></A>
<PRE>   // illustrates the use of the binary search algorithm
   // see alg7.cpp for complete source code
{
      // make an ordered vector of 15 random integers
   vector&lt;int&gt; aVec(15);
   generate (aVec.begin(), aVec.end(), randomValue);
   sort (aVec.begin(), aVec.end());

      // see if it contains an eleven
   if (binary_search (aVec.begin(), aVec.end(), 11))
      cout &lt;&lt; "contains an 11" &lt;&lt; endl;
   else
      cout &lt;&lt; "does not contain an 11" &lt;&lt; endl;

      // insert an 11 and a 14
   vector&lt;int&gt;::iterator where;
   where = lower_bound (aVec.begin(), aVec.end(), 11);
   aVec.insert (where, 11);

   where = upper_bound (aVec.begin(), aVec.end(), 14);
   aVec.insert (where, 14);

}</PRE>
</UL>

<HR>
<A HREF="14-3.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="14-5.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><P>OEM Edition, &copy;Copyright 1999, Rogue Wave Software, Inc.<BR><A HREF="contact.htm">Contact</A> Rogue Wave about documentation or support issues.</P>
</BODY></HTML>
