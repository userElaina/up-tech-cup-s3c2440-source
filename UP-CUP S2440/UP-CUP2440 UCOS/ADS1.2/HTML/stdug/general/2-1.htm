<HTML><HEAD><TITLE>2.1 Introduction to Iterators</TITLE></HEAD>
<BODY BGCOLOR=#FFFFFF>
<A HREF="../index.htm"><IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0></A><BR>
<A HREF="2.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="2-2.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<H2>2.1 Introduction to Iterators</H2>
<A NAME="idx8"><!></A>
<P>The concept of iterators is fundamental to using the container classes and the associated algorithms provided by the Standard C++ Library. An <I>iterator</I> is a pointer-like object used to cycle through all the elements stored in a container. Because different algorithms need to traverse containers in a variety of fashions, there are different forms of iterators. Each container class in the Standard C++ Library can generate an iterator with functionality appropriate to the storage technique used in implementing the container. It is the category of iterators required as arguments that chiefly distinguishes which algorithms in the Standard C++ Library can be used with which container classes. </P>
<A NAME="idx9"><!></A>
<P>Just as pointers can be used in a variety of ways in traditional programming, iterators can be used for a number of different purposes. An iterator can be used to denote a specific value, just as a pointer can be used to reference a specific memory location. A <I>pair</I> of iterators can be used to define a <I>range</I> or sequence of values held in a container, just as two pointers can be used to describe a contiguous region of memory. With iterators, however, the values being described may be only logically rather than physically in sequence because they are derived from the same container, and the second follows the first in the order in which the elements are maintained by the container.</P>
<A NAME="idx10"><!></A>
<P>Conventional pointers can sometimes be <I>null</I>, meaning they point at nothing. Iterators, as well, can fail to denote any specific value. Just as it is a logical error to dereference a null pointer, it is an error to dereference an iterator that is not denoting a value. </P>
<P>When two pointers that describe a region in memory are used in a C++ program, it is conventional that the ending pointer <I>not</I> be considered part of the region. For example, an array named <SAMP>x</SAMP> of length <SAMP>10</SAMP> is sometimes described as extending from <SAMP>x</SAMP> to <SAMP>x+10</SAMP>, even though the element at <SAMP>x+10</SAMP> is not part of the array. Instead, the pointer value <SAMP>x+10</SAMP> is the <I>past-the-end</I> value <I>after</I> the end of the range being described. Iterators are used similarly to describe a range. The second value is not considered part of the range being denoted. Instead, the second value is a <I>past-the-end</I> element describing the next value in sequence after the final value of the range. Sometimes, as with pointers to memory, this will be an actual value in the container. Other times it may be a special value, specifically constructed for the purpose. In either case, it is not proper to dereference an iterator that is being used to specify the end of a range. </P>
<A NAME="idx11"><!></A>
<P>Just as with conventional pointers, the fundamental operation used to modify an iterator is the increment operator <SAMP>++</SAMP>. When the increment operator is applied to an iterator that denotes the final value in a sequence, it is changed to the past-the-end value. An iterator <SAMP>j</SAMP> is said to be <I>reachable</I> from an iterator <SAMP>i</SAMP> if, after a finite sequence of applications of the expression <SAMP>++i</SAMP>, the iterator <SAMP>i</SAMP> becomes equal to <SAMP>j</SAMP>.</P>
<A NAME="idx12"><!></A>
<P>Ranges can be used to describe the entire contents of a container by constructing an iterator to the initial element and a special <I>ending</I> iterator. Ranges can also be used to describe sub-sequences within a single container by employing two iterators to specific values. </P>
<BLOCKQUOTE><HR>
<B>NOTE: Whenever two iterators are used to describe a range, it is assumed that the second iterator is reachable from the first, but this is not verified. Errors can occur if this expectation is not satisfied.
</B><HR></BLOCKQUOTE>
<P>In the remainder of this chapter, we describe the different forms of iterators used by the Standard C++ Library, as well as various other iterator-related functions.</P>

<HR>
<A HREF="2.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="2-2.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><P>OEM Edition, &copy;Copyright 1999, Rogue Wave Software, Inc.<BR><A HREF="contact.htm">Contact</A> Rogue Wave about documentation or support issues.</P>
</BODY></HTML>
