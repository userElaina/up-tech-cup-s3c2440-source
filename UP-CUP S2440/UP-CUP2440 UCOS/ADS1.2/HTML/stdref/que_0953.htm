<HTML><HEAD><TITLE>queue</TITLE></HEAD><BODY BGCOLOR=#FFFFFF>
<IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0><BR>
<A HREF="pus_5295.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="Ran_7821.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><BR>

<H2>queue</H2>
<PRE><HR>Container Adaptor
<HR></PRE>
<UL>
<LI><A HREF="#Summary">Summary</A></LI>
<LI><A HREF="#memindex">Data Type and Member Function Indexes</A></LI>
<LI><A HREF="#Synopsis">Synopsis</A></LI>
<LI><A HREF="#Description">Description</A></LI>
<LI><A HREF="#Interface">Interface</A></LI>
<LI><A HREF="#Constructors">Constructors</A></LI>
<LI><A HREF="#Member Functions">Member Functions</A></LI>
<LI><A HREF="#Non-member Operators">Non-member Operators</A></LI>
<LI><A HREF="#Example">Example</A></LI>
<LI><A HREF="#Warnings">Warnings</A></LI>
<LI><A HREF="#See Also">See Also</A></LI>

</UL>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A container adaptor that behaves like a queue (first in, first out).</P>
<A NAME="memindex"><H3>Data Type and Member Function Indexes<BR>(exclusive of constructors and destructors)</H3></A>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Member Functions</B></TD></TR><TR><TD VALIGN=top><A HREF="#Member Functionsback()">back()</A><BR>
 <A HREF="#Member Functionsempty()">empty()</A><BR>
 <A HREF="#Member Functionsfront()">front()</A><BR>
 <A HREF="#Non-member Operatorsoperator!=()">operator!=()</A><BR>
 <A HREF="#Non-member Operatorsoperator&gt;()">operator&gt;()</A><BR>
 <A HREF="#Non-member Operatorsoperator&lt;()">operator&lt;()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Non-member Operatorsoperator==()">operator==()</A><BR>
 <A HREF="#Member Functionspop()">pop()</A><BR>
 <A HREF="#Member Functionspush()">push()</A><BR>
 <A HREF="#Member Functionssize()">size()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>
<PRE>#include &lt;queue&gt;
template &lt;class T, class Container = deque&lt;T&gt; &gt; 
  class <B>queue</B> ;</PRE>

</PRE>

<A NAME="Description"><H3>Description</H3></A>
<P>The <B><I>queue</I></B> container adaptor lets a container act as a queue. In a queue, items are pushed into the back of the container and removed from the front. The first items pushed into the queue are the first items to be popped off of the queue (first in, first out, or "FIFO"). </P>
<P><B><I>queue</I></B> can adapt any container that supports the <SAMP>front()</SAMP>, <SAMP>back()</SAMP>, <SAMP>push_back()</SAMP>, and <SAMP>pop_front()</SAMP> operations. In particular, <B><I><A HREF="deq_4164.htm">deque</A></I></B> and <B><I><A HREF="lis_3222.htm">list</A></I></B> can be used. </P>

<A NAME="Interface"><H3>Interface</H3></A>
<PRE>
<PRE>template &lt;class T, class Container = deque&lt;T&gt; &gt;
 class queue {

public:

// typedefs

   typedef typename Container::value_type value_type;
   typedef typename Container::size_type size_type;
   typedef Container container_type;

// Construct/Copy/Destroy
   explicit queue (const Container&amp; = Container());

// Accessors

   bool empty () const;
   size_type size () const;
   value_type&amp; front ();
   const value_type&amp; front () const;
   value_type&amp; back ();
   const value_type&amp; back () const;
   void push (const value_type&amp;);
   void pop ();
};

// Non-member Operators

template &lt;class T, class Container&gt;
 bool operator== (const queue&lt;T, Container&gt;&amp;,
                  const queue&lt;T, Container&gt;&amp;);

template &lt;class T, class Container&gt;
 bool operator!= (const queue&lt;T, Container&gt;&amp;,
                  const queue&lt;T, Container&gt;&amp;);

template &lt;class T, class Container&gt;
 bool operator&lt; (const queue&lt;T, Container&gt;&amp;,
                 const queue&lt;T, Container&gt;&amp;);

template &lt;class T, class Container&gt;
 bool operator&gt; (const queue&lt;T, Container&gt;&amp;,
                 const queue&lt;T, Container&gt;&amp;);

template &lt;class T, class Container&gt;
 bool operator&lt;= (const queue&lt;T, Container&gt;&amp;,
                 const queue&lt;T, Container&gt;&amp;);

template &lt;class T, class Container&gt;
 bool operator&gt;= (const queue&lt;T, Container&gt;&amp;,
                 const queue&lt;T, Container&gt;&amp;);</PRE>

</PRE>

<A NAME="Constructors"><H3>Constructors</H3></A>


<PRE>explicit <B>queue</B> (const Container&amp; = Container());</PRE>

<UL>
<P>Creates a queue of zero elements. The queue uses the allocator   <SAMP>Allocator()</SAMP> for all storage management.</P>
</UL>


<A NAME="Member Functions"><H3>Member Functions</H3></A>


<A NAME="Member Functionsback()"></A><PRE>value_type&amp; 
<B>back</B> ();</PRE>

<UL>
<P>Returns a reference to the item at the back of the queue (the last item pushed into the queue).</P>
</UL>



<PRE>const value_type&amp; 
<B>back</B>() const;</PRE>

<UL>
<P>Returns a constant reference to the item at the back of the queue as a <SAMP>const_value_type</SAMP>.</P>
</UL>



<A NAME="Member Functionsempty()"></A><PRE>bool 
<B>empty</B> () const;</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the queue is empty, otherwise <SAMP>false</SAMP>.</P>
</UL>



<A NAME="Member Functionsfront()"></A><PRE>value_type&amp; 
<B>front</B> ();</PRE>

<UL>
<P>Returns a reference to the item at the front of the queue. This is the first item pushed onto the queue unless <SAMP>pop()</SAMP> has been called since then.</P>
</UL>



<PRE>const value_type&amp; 
<B>front</B> () const;</PRE>

<UL>
<P>Returns a constant reference to the item at the front of the queue as a <SAMP>const_value_type</SAMP>.</P>
</UL>



<A NAME="Member Functionspop()"></A><PRE>void 
<B>pop</B> ();</PRE>

<UL>
<P>Removes the item at the front of the queue.</P>
</UL>



<A NAME="Member Functionspush()"></A><PRE>void 
<B>push</B> (const value_type&amp; x);</PRE>

<UL>
<P>Pushes <SAMP>x</SAMP> onto the back of the queue.</P>
</UL>



<A NAME="Member Functionssize()"></A><PRE>size_type 
<B>size</B> () const;</PRE>

<UL>
<P>Returns the number of elements on the queue.</P>
</UL>


<A NAME="Non-member Operators"><H3>Non-member Operators</H3></A>


<A NAME="Non-member Operatorsoperator==()"></A><PRE>template &lt;class T, class Container&gt;
  bool <B>operator==</B> (const queue&lt;T, Container&gt;&amp; x,
                   const queue&lt;T, Container&gt;&amp; y);</PRE>

<UL>
<P>   Returns <SAMP>true</SAMP> if <SAMP>x</SAMP> is the same as <SAMP>y</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator!=()"></A><PRE>template &lt;class T, class Container&gt;
  bool <B>operator!=</B> (const queue&lt;T, Container&gt;&amp; x,
                   const queue&lt;T, Container&gt;&amp; y);</PRE>

<UL>
<P>   Returns <SAMP>!(x==y)</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&lt;()"></A><PRE>template &lt;class T, class Container&gt;
  bool <B>operator&lt;</B> (const queue&lt;T, Container&gt;&amp; x,
                  const queue&lt;T, Container&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>true</SAMP> if the queue defined by the elements contained in <SAMP>x</SAMP> is    lexicographically less than the queue defined by the elements contained in <SAMP>y</SAMP>.</P>
</UL>



<A NAME="Non-member Operatorsoperator&gt;()"></A><PRE>template &lt;class T, class Container&gt;
  bool <B>operator&gt;</B> (const queue&lt;T, Container&gt;&amp; x,
                  const queue&lt;T, Container&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>y &lt; x</SAMP>.</P>
</UL>



<PRE>template &lt;class T, class Container&gt;
  bool <B>operator&lt;</B> (const queue&lt;T, Container&gt;&amp; x,
                  const queue&lt;T, Container&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>!(y &lt; x)</SAMP>.</P>
</UL>



<PRE>template &lt;class T, class Container&gt;
  bool <B>operator&lt;</B> (const queue&lt;T, Container&gt;&amp; x,
                  const queue&lt;T, Container&gt;&amp; y);</PRE>

<UL>
<P>Returns <SAMP>!(x &lt; y)</SAMP>.</P>
</UL>


<A NAME="Example"><H3>Example</H3></A>
<UL>
<PRE>//
// queue.cpp
//
 #include &lt;queue&gt;
 #include &lt;string&gt;
 #include &lt;deque&gt;
 #include &lt;list&gt;
 #include &lt;iostream&gt;
 using namespace std;

 int main(void)
 {
   // Make a queue using a list container
   <B>queue</B>&lt;int, list&lt;int&gt;&gt; q;

   // Push a couple of values on then pop them off 
   q.push(1);
   q.push(2);
   cout &lt;&lt; q.front() &lt;&lt; endl;
   q.pop();
   cout &lt;&lt; q.front() &lt;&lt; endl;
   q.pop();

   // Make a queue of strings using a deque container
   <B>queue</B>&lt;string,deque&lt;string&gt;&gt; qs;

   // Push on a few strings then pop them back off
   int i;
   for (i = 0; i &lt; 10; i++)
   {
     qs.push(string(i+1,'a'));
     cout &lt;&lt; qs.front() &lt;&lt; endl;
   }
   for (i = 0; i &lt; 10; i++)
   {
     cout &lt;&lt; qs.front() &lt;&lt; endl;
     qs.pop();
   }

   return 0;
 }</PRE>

</UL>
<P><B>Program Output</B></P>
<UL>
<PRE>
1
2
a
a
a
a
a
a
a
a
a
a
a
aa
aaa
aaaa
aaaaa
aaaaaa
aaaaaaa
aaaaaaaa
aaaaaaaaa
aaaaaaaaaa</PRE>

</UL>

<A NAME="Warnings"><H3>Warnings</H3></A>
<P>If your compiler does not support default template parameters, you must always include a <SAMP>Container</SAMP> template parameter. For example you would not be able to write:</P>
<P><SAMP>queue&lt;int&gt; var;</SAMP></P>
<P>rather, you would have to write,</P>
<P><SAMP>queue&lt;int, deque&lt;int&gt; &gt; var;</SAMP></P>
<P>If your compiler does not support namespaces, then you do not need the using declaration for <SAMP>std</SAMP>.</P>

<A NAME="See Also"><H3>See Also</H3></A>
<P><B><I><A HREF="all_7029.htm">allocator</A></I></B>, <B><I><A HREF="Con_2487.htm">Containers</A></I></B>, <B><I><A HREF="pri_2327.htm">priority_queue</A></I></B></P>


<BR>
<HR>
<A HREF="pus_5295.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="Ran_7821.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<BR>&copy;Copyright 1999, Rogue Wave Software, Inc.<BR>Send <A HREF="mailto:onlinedocs@roguewave.com">mail</A> to report errors or comment on the documentation.
<BR>
OEM Release</BODY></HTML>
