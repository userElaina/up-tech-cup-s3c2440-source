<HTML><HEAD><TITLE>numeric_limits</TITLE></HEAD><BODY BGCOLOR=#FFFFFF>
<IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0><BR>
<A HREF="num_8322.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="num_2619.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><BR>

<H2>numeric_limits</H2>
<PRE><HR>Numeric Limits Library
<HR></PRE>
<UL>
<LI><A HREF="#Summary">Summary</A></LI>
<LI><A HREF="#memindex">Data Type and Member Function Indexes</A></LI>
<LI><A HREF="#Specializations">Specializations</A></LI>
<LI><A HREF="#Synopsis">Synopsis</A></LI>
<LI><A HREF="#Description">Description</A></LI>
<LI><A HREF="#Interface">Interface</A></LI>
<LI><A HREF="#Member Fields and Functions">Member Fields and Functions</A></LI>
<LI><A HREF="#Example">Example</A></LI>
<LI><A HREF="#Warnings">Warnings</A></LI>
<LI><A HREF="#See Also">See Also</A></LI>

</UL>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A class for representing information about scalar types.</P>
<A NAME="memindex"><H3>Data Type and Member Function Indexes<BR>(exclusive of constructors and destructors)</H3></A>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Data Types</B></TD></TR><TR><TD VALIGN=top><A HREF="#Member Fields and Functionsdigits">digits</A><BR>
 <A HREF="#Member Fields and Functionsdigits10">digits10</A><BR>
 <A HREF="#Member Fields and Functionshas_denorm">has_denorm</A><BR>
 <A HREF="#Member Fields and Functionshas_infinity">has_infinity</A><BR>
 <A HREF="#Member Fields and Functionshas_quiet_NaN">has_quiet_NaN</A><BR>
 <A HREF="#Member Fields and Functionshas_signaling_NaN">has_signaling_NaN</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Fields and Functionsis_bounded">is_bounded</A><BR>
 <A HREF="#Member Fields and Functionsis_exact">is_exact</A><BR>
 <A HREF="#Member Fields and Functionsis_iec559">is_iec559</A><BR>
 <A HREF="#Member Fields and Functionsis_integer">is_integer</A><BR>
 <A HREF="#Member Fields and Functionsis_modulo">is_modulo</A><BR>
 <A HREF="#Member Fields and Functionsis_signed">is_signed</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Fields and Functionsis_specialized">is_specialized</A><BR>
 <A HREF="#Member Fields and Functionsmax_exponent">max_exponent</A><BR>
 <A HREF="#Member Fields and Functionsmax_exponent10">max_exponent10</A><BR>
 <A HREF="#Member Fields and Functionsmin_exponent">min_exponent</A><BR>
 <A HREF="#Member Fields and Functionsmin_exponent10">min_exponent10</A><BR>
 <A HREF="#Member Fields and Functionsradix">radix</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Fields and Functionsround_style">round_style</A><BR>
 <A HREF="#Member Fields and Functionstinyness_before">tinyness_before</A><BR>
 <A HREF="#Member Fields and Functionstraps">traps</A><BR>
</TD></TR>
</TABLE></UL>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Member Functions</B></TD></TR><TR><TD VALIGN=top><A HREF="#Member Fields and Functionsdenorm_min()">denorm_min()</A><BR>
 <A HREF="#Member Fields and Functionsepsilon()">epsilon()</A><BR>
 <A HREF="#Member Fields and Functionsinfinity()">infinity()</A><BR>
 <A HREF="#Member Fields and Functionsmax()">max()</A><BR>
 <A HREF="#Member Fields and Functionsmin()">min()</A><BR>
 <A HREF="#Member Fields and Functionsquiet_NaN()">quiet_NaN()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Member Fields and Functionsround_error()">round_error()</A><BR>
 <A HREF="#Member Fields and Functionssignaling_NaN()">signaling_NaN()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="Specializations"><H3>Specializations</H3></A>
<PRE>
<PRE>numeric_limits&lt;float&gt;
numeric_limits&lt;double&gt;
numeric_limits&lt;long double&gt;
numeric_limits&lt;short&gt;
numeric_limits&lt;unsigned short&gt;
numeric_limits&lt;int&gt;
numeric_limits&lt;unsigned int&gt;
numeric_limits&lt;long&gt;
numeric_limits&lt;unsigned long&gt;
numeric_limits&lt;char&gt;
numeric_limits&lt;wchar_t&gt;
numeric_limits&lt;unsigned char&gt;
numeric_limits&lt;signed char&gt;
numeric_limits&lt;bool&gt;</PRE>

</PRE>

<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>
<PRE>#include &lt;limits&gt;
template &lt;class T&gt;
class <B>numeric_limits ;</B></PRE>

</PRE>

<A NAME="Description"><H3>Description</H3></A>
<P><B><I>numeric_limits</I></B> is a class for representing information about scalar types. Specializations are included for each fundamental type, both floating point and integer, including <SAMP>bool</SAMP>. </P>
<P>This class encapsulates information that is contained in the <SAMP>&lt;climits&gt;</SAMP> and <SAMP>&lt;cfloat&gt;</SAMP> headers, and includes additional information that is not contained in any existing C or C++ header. </P>
<P>Not all of the information given by members is meaningful for all specializations of <B><I>numeric_limits</I></B>. Any value that is not meaningful for a particular type is set to <SAMP>0</SAMP> or <SAMP>false</SAMP>. </P>

<A NAME="Interface"><H3>Interface</H3></A>
<PRE>
<PRE>template &lt;class T&gt;
 class numeric_limits {

 public:

 // General -- meaningful for all specializations.

    static const bool is_specialized ;
    static T min () throw();
    static T max () throw();
    static const int radix ;
    static const int digits ;
    static const int digits10 ;
    static const bool is_signed ;
    static const bool is_integer ;
    static const bool is_exact ;
    static const bool traps ;
    static const bool is_modulo ;
    static const bool is_bounded ;

 // Floating point specific.

    static T epsilon () throw();
    static T round_error () throw();
    static const int min_exponent10 ;
    static const int max_exponent10 ;
    static const int min_exponent ;
    static const int max_exponent ;
    static const bool has_infinity ;
    static const bool has_quiet_NaN ;
    static const bool has_signaling_NaN ;
    static const bool is_iec559 ;
    static const float_denorm_style has_denorm ;
    static const bool has_denorm_loss;
    static const bool tinyness_before ;
    static const float_round_style round_style ;
    static T denorm_min () throw();
    static T infinity () throw();
    static T quiet_NaN () throw();
    static T signaling_NaN () throw();
 };

 enum float_round_style {
   round_indeterminate       = -1,
   round_toward_zero         =  0,
   round_to_nearest          =  1,
   round_toward_infinity     =  2,
   round_toward_neg_infinity =  3
 };
 enum float_denorm_style {
   denorm_indeterminate      = -1,
   denorm_absent             =  0,
   denorm_present            =  1
 };</PRE>

</PRE>

<A NAME="Member Fields and Functions"><H3>Member Fields and Functions</H3></A>


<A NAME="Member Fields and Functionsdenorm_min()"></A><PRE>static T 
<B>denorm_min</B> () throw();</PRE>

<UL>
<P>Returns the minimum denormalized value. Meaningful for all floating point types. For types that do not allow denormalized values, this method must return the minimum normalized value.</P>
</UL>



<A NAME="Member Fields and Functionsdigits"></A><PRE>static const int 
<B>digits</B> ;</PRE>

<UL>
<P>The number of radix digits that can be represented without change.   For built-in integer types, <SAMP>digits</SAMP> is usually the number of non-sign bits in the representation. For floating point types, <SAMP>digits</SAMP> is the number of radix digits in the mantissa. This member is meaningful for all specializations that declare <SAMP>is_bounded</SAMP> to be <SAMP>true</SAMP>.</P>
</UL>



<A NAME="Member Fields and Functionsdigits10"></A><PRE>static const int 
<B>digits10</B> ;</PRE>

<UL>
<P>The number of base 10 digits that can be represented without change.   This function is meaningful for all specializations that declare <SAMP>is_bounded</SAMP> to be <SAMP>true</SAMP>.</P>
</UL>



<A NAME="Member Fields and Functionsepsilon()"></A><PRE>static T 
<B>epsilon</B> () throw();</PRE>

<UL>
<P>Returns the machine epsilon (the difference between <SAMP>1</SAMP> and the least value greater than <SAMP>1</SAMP> that is representable). This function is meaningful for floating point types only.</P>
</UL>



<A NAME="Member Fields and Functionshas_denorm"></A><PRE>static const float_denorm_style 
<B>has_denorm</B> ;</PRE>

<UL>
<P>Returns <SAMP>denorm_present</SAMP> if the type allows denormalized values. Returns <SAMP>denorm_absent</SAMP> if the type does not allow denormalized values. Returns <SAMP>denorm_indeterminate</SAMP> if it is indeterminate at compile time whether the type allows denormalized values. It is meaningful for floating point types only.</P>
</UL>



<A NAME="Member Fields and Functionshas_infinity"></A><PRE>static const bool 
<B>has_infinity</B> ;</PRE>

<UL>
<P>This field is <SAMP>true</SAMP> if the type has a representation for positive infinity.   It is meaningful for floating point types only. This field must be <SAMP>true</SAMP> for any type claiming conformance to IEC 559.</P>
</UL>



<A NAME="Member Fields and Functionshas_quiet_NaN"></A><PRE>static const bool 
<B>has_quiet_NaN</B> ;</PRE>

<UL>
<P>This field is <SAMP>true</SAMP> if the type has a representation for a quiet (non-signaling) "Not a Number". It is meaningful for floating point types only and must be <SAMP>true</SAMP> for any type claiming conformance to IEC 559.</P>
</UL>



<A NAME="Member Fields and Functionshas_signaling_NaN"></A><PRE>static const bool 
<B>has_signaling_NaN</B> ;</PRE>

<UL>
<P>This field is <SAMP>true</SAMP> if the type has a representation for a signaling "Not a Number".   It is meaningful for floating point types only, and must be <SAMP>true</SAMP> for any type claiming conformance to IEC 559.</P>
</UL>



<A NAME="Member Fields and Functionsinfinity()"></A><PRE>static T 
<B>infinity</B> () throw();</PRE>

<UL>
<P>Returns the representation of positive infinity, if available. This member function is meaningful for only those specializations that declare <SAMP>has_infinity</SAMP> to be <SAMP>true</SAMP>. Required for any type claiming conformance to IEC 559.</P>
</UL>



<A NAME="Member Fields and Functionsis_bounded"></A><PRE>static const bool 
<B>is_bounded</B> ;</PRE>

<UL>
<P>This field is <SAMP>true</SAMP> if the set of values representable by the type is finite. All built-in C types are bounded; this member would be <SAMP>false</SAMP> for arbitrary precision types.</P>
</UL>



<A NAME="Member Fields and Functionsis_exact"></A><PRE>static const bool 
<B>is_exact</B> ;</PRE>

<UL>
<P>This static member field is <SAMP>true</SAMP> if the type uses an exact representation. All integer types are exact, but not vice versa. For example, rational and fixed-exponent representations are exact but not integer. This member is meaningful for all specializations.</P>
</UL>



<A NAME="Member Fields and Functionsis_iec559"></A><PRE>static const bool 
<B>is_iec559</B> ;</PRE>

<UL>
<P>This member is <SAMP>true</SAMP> if and only if the type adheres to the IEC 559 standard. It is meaningful for floating point types only.</P>
</UL>



<A NAME="Member Fields and Functionsis_integer"></A><PRE>static const bool 
<B>is_integer</B> ;</PRE>

<UL>
<P>This member is <SAMP>true</SAMP> if the type is integer. This member is meaningful for all specializations.</P>
</UL>



<A NAME="Member Fields and Functionsis_modulo"></A><PRE>static const bool 
<B>is_modulo</B> ;</PRE>

<UL>
<P>This field is <SAMP>true</SAMP> if the type is modulo. Generally, this is <SAMP>false</SAMP> for floating types, <SAMP>true</SAMP> for unsigned integers, and <SAMP>true</SAMP> for signed integers on most machines. A type is modulo if it is possible to add two positive numbers and have a result that wraps around to a third number, which is less.</P>
</UL>



<A NAME="Member Fields and Functionsis_signed"></A><PRE>static const bool 
<B>is_signed</B> ;</PRE>

<UL>
<P>This member is <SAMP>true</SAMP> if the type is signed. This member is meaningful for all specializations.</P>
</UL>



<A NAME="Member Fields and Functionsis_specialized"></A><PRE>static const bool 
<B>is_specialized</B> ;</PRE>

<UL>
<P>Indicates whether <B><I>numeric_limits</I></B> has been specialized for type <SAMP>T</SAMP>. This flag must be <SAMP>true</SAMP> for all specializations of <SAMP>numeric_limits</SAMP>. For the default <B><I>numeric_limits&lt;T&gt;</I></B> template, this flag must be <SAMP>false</SAMP>. </P>
</UL>



<A NAME="Member Fields and Functionsmax()"></A><PRE>static T
<B>max</B> () throw();</PRE>

<UL>
<P>Returns the maximum finite value. This function is meaningful for all specializations that declare <SAMP>is_bounded</SAMP> to be <SAMP>true</SAMP>.</P>
</UL>



<A NAME="Member Fields and Functionsmax_exponent"></A><PRE>static const int 
<B>max_exponent</B> ;</PRE>

<UL>
<P>The maximum positive integer such that the radix raised to the power one less than that integer is in range. This field is meaningful for floating point types only.</P>
</UL>



<A NAME="Member Fields and Functionsmax_exponent10"></A><PRE>static const int 
<B>max_exponent10</B> ;</PRE>

<UL>
<P>The maximum positive integer such that 10 raised to that power is in range. This field is meaningful for floating point types only.</P>
</UL>



<A NAME="Member Fields and Functionsmin()"></A><PRE>static T 
<B>min</B> () throw();</PRE>

<UL>
<P>Returns the minimum finite value. For floating point types with denormalization, <SAMP>min()</SAMP>must return the minimum normalized value. The minimum denormalized value is given by <SAMP>denorm_min()</SAMP>. This function is meaningful for all specializations that declare <SAMP>is_bounded</SAMP> to be <SAMP>true</SAMP>, or <SAMP>is_bounded == false &amp;&amp; is_signed == false</SAMP>.</P>
</UL>



<A NAME="Member Fields and Functionsmin_exponent"></A><PRE>static const int 
<B>min_exponent</B> ;</PRE>

<UL>
<P>The minimum negative integer such that the radix raised to the power one less than that integer is in range. This field is meaningful for floating point types only.</P>
</UL>



<A NAME="Member Fields and Functionsmin_exponent10"></A><PRE>static const int 
<B>min_exponent10</B> ;</PRE>

<UL>
<P>The minimum negative integer such that 10 raised to that power is in range. This field is meaningful for floating point types only.</P>
</UL>



<A NAME="Member Fields and Functionsquiet_NaN()"></A><PRE>static T 
<B>quiet_NaN</B> () throw();</PRE>

<UL>
<P>Returns the representation of a quiet "Not a Number", if available.   This function is meaningful only for those specializations that declare <SAMP>has_quiet_NaN</SAMP> to be <SAMP>true</SAMP>. This field is required for any type claiming conformance to IEC 559.</P>
</UL>



<A NAME="Member Fields and Functionsradix"></A><PRE>static const int 
<B>radix</B> ;</PRE>

<UL>
<P>For floating types, specifies the base or radix of the exponent representation (often 2). For integer types, this member must specify the base of the representation. This field is meaningful for all specializations.</P>
</UL>



<A NAME="Member Fields and Functionsround_error()"></A><PRE>static T 
<B>round_error</B> () throw();</PRE>

<UL>
<P>Returns the measure of the maximum rounding error. This function is meaningful for floating point types only.</P>
</UL>



<A NAME="Member Fields and Functionsround_style"></A><PRE>static const float_round_style 
<B>round_style</B> ;</PRE>

<UL>
<P>The rounding style for the type. Specializations for integer types must return <SAMP>round_toward_zero</SAMP>. This is meaningful for all floating point types.</P>
</UL>



<A NAME="Member Fields and Functionssignaling_NaN()"></A><PRE>static T 
<B>signaling_NaN</B>() throw();</PRE>

<UL>
<P>Returns the representation of a signaling "Not a Number", if available. This function is meaningful for only those specializations that declare <SAMP>has_signaling_NaN</SAMP> to be <SAMP>true</SAMP>. This function must be meaningful for any type claiming conformance to IEC 559.</P>
</UL>



<A NAME="Member Fields and Functionstinyness_before"></A><PRE>static const bool 
<B>tinyness_before</B> ;</PRE>

<UL>
<P>This member is <SAMP>true</SAMP> if <SAMP>tinyness</SAMP> is detected before rounding. It is meaningful for floating point types only.</P>
</UL>



<A NAME="Member Fields and Functionstraps"></A><PRE>static const bool 
<B>traps</B> ;</PRE>

<UL>
<P>This field is <SAMP>true</SAMP> if trapping is implemented for this type.   The <SAMP>traps</SAMP> field is meaningful for all specializations.</P>
</UL>


<A NAME="Example"><H3>Example</H3></A>
<UL>
<PRE>//
// limits.cpp
//
 #include &lt;limits&gt;
 #include &lt;iostream&gt;
 using namespace std;


 int main() 
 {
    <B>numeric_limits</B>&lt;float&gt; float_info;
    if (float_info.is_specialized &amp;&amp;
        float_info.has_infinity)
    {
      // get value of infinity 
      cout&lt;&lt; float_info.infinity() &lt;&lt; endl; 
    }
    return 0;
 }</PRE>

</UL>

<A NAME="Warnings"><H3>Warnings</H3></A>
<P>The specializations for <SAMP>wide</SAMP> <SAMP>chars</SAMP> and <SAMP>bool</SAMP> are only available if your compiler has implemented them as real types and not simulated them with typedefs. </P>
<P>If your compiler does not support namespaces, then you do not need the using declaration for <SAMP>std</SAMP>.</P>

<A NAME="See Also"><H3>See Also</H3></A>
<P>IEEE Standard for Binary Floating-Point Arithmetic, 345 East 47th Street, New York, NY 10017</P>
<P>Language Independent Arithmetic (LIA-1)</P>


<BR>
<HR>
<A HREF="num_8322.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="num_2619.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<BR>&copy;Copyright 1999, Rogue Wave Software, Inc.<BR>Send <A HREF="mailto:onlinedocs@roguewave.com">mail</A> to report errors or comment on the documentation.
<BR>
OEM Release</BODY></HTML>
