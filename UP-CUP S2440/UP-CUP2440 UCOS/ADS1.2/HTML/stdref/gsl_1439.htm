<HTML><HEAD><TITLE>gslice_array</TITLE></HEAD><BODY BGCOLOR=#FFFFFF>
<IMG SRC="images/banner.gif" WIDTH=405 HEIGHT=57 ALT="Rogue Wave banner" BORDER=0><BR>
<A HREF="gsl_4121.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="has_4618.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A><BR>

<H2>gslice_array</H2>
<PRE><HR>Valarray helpers
<HR></PRE>
<UL>
<LI><A HREF="#Summary">Summary</A></LI>
<LI><A HREF="#memindex">Data Type and Member Function Indexes</A></LI>
<LI><A HREF="#Synopsis">Synopsis</A></LI>
<LI><A HREF="#Description">Description</A></LI>
<LI><A HREF="#Interface">Interface</A></LI>
<LI><A HREF="#Constructors">Constructors</A></LI>
<LI><A HREF="#Assignment Operators">Assignment Operators</A></LI>
<LI><A HREF="#Computed Assignment Operators">Computed Assignment Operators</A></LI>
<LI><A HREF="#Member Functions">Member Functions</A></LI>
<LI><A HREF="#Example">Example</A></LI>
<LI><A HREF="#Warnings">Warnings</A></LI>
<LI><A HREF="#See Also">See Also</A></LI>

</UL>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A numeric array class used to represent a BLAS-like slice from a <B><I><A HREF="val_6244.htm">valarray</A></I></B>.</P>
<A NAME="memindex"><H3>Data Type and Member Function Indexes<BR>(exclusive of constructors and destructors)</H3></A>
<UL><TABLE CELLPADDING=3>
<TR><TD><B>Member Functions</B></TD></TR><TR><TD VALIGN=top><A HREF="#Computed Assignment Operatorsoperator%=()">operator%=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator&amp;=()">operator&amp;=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator&gt;&gt;=()">operator&gt;&gt;=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator&lt;&lt;=()">operator&lt;&lt;=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator*=()">operator*=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator+=()">operator+=()</A><BR>
</TD>
<TD VALIGN=top> <A HREF="#Computed Assignment Operatorsoperator-=()">operator-=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator/=()">operator/=()</A><BR>
 <A HREF="#Assignment Operatorsoperator=()">operator=()</A><BR>
 <A HREF="#Computed Assignment Operatorsoperator^=()">operator^=()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>
<PRE>#include &lt;valarray&gt;
template &lt;class T&gt;
class <B>gslice_array</B> ;</PRE>

</PRE>

<A NAME="Description"><H3>Description</H3></A>
<P><B><I>gslice_array&lt;T&gt;</I></B> creates a <B><I><A HREF="gsl_4121.htm">gslice</A></I></B> view into a <B><I><A HREF="val_6244.htm">valarray</A></I></B>. <B><I>gslice_arrays</I></B> are only produced by applying the <B><I>gslice</I></B> subscript operator to a <B><I>valarray</I></B>. The elements in a <B><I>gslice_array</I></B> are references to selected elements in the <B><I>valarray</I></B> (so changing an element in the <B><I>gslice_array</I></B> really changes the corresponding element in the <B><I>valarray</I></B>). A <B><I>gslice_array</I></B> does not itself hold any distinct elements. The template cannot be instantiated directly since all its constructors are private. However, you can copy a <B><I>gslice_array</I></B> to a <B><I>valarray</I></B> using either the <B><I>valarray</I></B> copy constructor or the assignment operator. Reference semantics are lost at that point. </P>

<A NAME="Interface"><H3>Interface</H3></A>
<PRE>
<PRE>template &lt;class T&gt; class gslice_array {
public:

  // types
  typedef T value_type;

  // destructor
  ~gslice_array();

  // public assignment
  void operator= (const valarray&lt;T&gt;&amp; array) const;
  // computed assignment
  void operator*= (const valarray&lt;T&gt;&amp; array) const;
  void operator/= (const valarray&lt;T&gt;&amp; array) const;
  void operator%= (const valarray&lt;T&gt;&amp; array) const;
  void operator+= (const valarray&lt;T&gt;&amp; array) const;
  void operator-= (const valarray&lt;T&gt;&amp; array) const;
  void operator^= (const valarray&lt;T&gt;&amp; array) const;
  void operator&amp;= (const valarray&lt;T&gt;&amp; array) const;
  void operator|= (const valarray&lt;T&gt;&amp; array) const;
  void operator&lt;&lt;= (const valarray&lt;T&gt;&amp; array) const;
  void operator&gt;&gt;= (const valarray&lt;T&gt;&amp; array) const;
 
  // fill function
  void operator=(const T&amp;);  

private:
  // constructors
  gslice_array();
  gslice_array(const gslice_array&lt;T&gt;&amp;);
  // operator =
  gslice_array&lt;T&gt;&amp; operator= (const gslice_array&lt;T&gt;&amp; array);
};</PRE>

</PRE>

<A NAME="Constructors"><H3>Constructors</H3></A>


<PRE><B>gslice_array</B>();
<B>gslice_array</B>(const gslice_array&amp;);</PRE>

<UL>
<P>All <B><I>gslice_array</I></B> constructors are private and cannot be called directly. This prevents copy construction of <B><I>gslice_arrays</I></B>.</P>
</UL>


<A NAME="Assignment Operators"><H3>Assignment Operators</H3></A>


<A NAME="Assignment Operatorsoperator=()"></A><PRE>void <B>operator=</B>(const valarray&lt;T&gt;&amp; x) const;</PRE>

<UL>
<P>Assigns values from <SAMP>x</SAMP> to the selected elements of the <B><I><A HREF="val_6244.htm">valarray</A></I></B> that self refers to. Remember that a <B><I>gslice_array</I></B> never holds any elements itself; it simply refers to selected elements in the <B><I>valarray</I></B> used to generate it.</P>
</UL>



<PRE>gslice_array&lt;T&gt;&amp; 
<B>operator=</B>(const gslice-_array&lt;T&gt;&amp; x);</PRE>

<UL>
<P>Private assignment operator. Cannot be called directly, thus preventing assignment between <B><I>gslice_arrays</I></B>.</P>
</UL>


<A NAME="Computed Assignment Operators"><H3>Computed Assignment Operators</H3></A>


<A NAME="Computed Assignment Operatorsoperator*=()"></A><PRE>void <B>operator*=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator/=()"></A>void <B>operator/=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator%=()"></A>void <B>operator%=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator+=()"></A>void <B>operator+=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator-=()"></A>void <B>operator-=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator^=()"></A>void <B>operator^=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator&amp;=()"></A>void <B>operator&amp;=</B>(const valarray&lt;T&gt;&amp; val) const;
void <B>operator|=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator&lt;&lt;=()"></A>void <B>operator&lt;&lt;=</B>(const valarray&lt;T&gt;&amp; val) const;
<A NAME="Computed Assignment Operatorsoperator&gt;&gt;=()"></A>void <B>operator&gt;&gt;=</B>(const valarray&lt;T&gt;&amp; val) const;</PRE>

<UL>
<P>Applies the indicated operation using elements from <SAMP>val</SAMP> to the selected elements of the <B><I><A HREF="val_6244.htm">valarray</A></I></B> that self refers to. Remember that a <B><I>gslice_array</I></B> never holds any elements itself; it simply refers to selected elements in the <B><I>valarray</I></B> used to generate it.</P>
</UL>


<A NAME="Member Functions"><H3>Member Functions</H3></A>


<PRE>void <B>operator=</B>(const T&amp; x) const;</PRE>

<UL>
<P>Assigns <SAMP>x</SAMP> to the selected elements of the <B><I><A HREF="val_6244.htm">valarray</A></I></B> that self refers to. </P>
</UL>


<A NAME="Example"><H3>Example</H3></A>
<UL>
<PRE>//
// gslice_array.cpp
//
#include "valarray.h" // Contains a valarray stream inserter
using namespace std;

int main(void)
{
  int ibuf[27] = 
   {0,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,2,3,4,5,6,7,8,9,10};
  int buf13[9] = {13,13,13,13,13,13,13,13,13};
  size_t len_buf[3] = {3,3,3};
  size_t stride_buf[3] = {9,3,1};

  // create a valarray of ints
  valarray&lt;int&gt;  vi(ibuf,27);

  // print out the valarray
  cout &lt;&lt; vi &lt;&lt; endl;

  // Get a two dimensional diagonal slice out of the middle
  valarray&lt;size_t&gt; len2(2);
  len2[0] = 3;
  len2[1] = 3;
  valarray&lt;size_t&gt; stride2(2);
  stride2[0] = 3;
  stride2[1] = 10;
  gslice_array&lt;int&gt; gsl = vi[gslice(0,len2,stride2)];

  // print out the slice
  cout &lt;&lt; gsl &lt;&lt; endl;

  // Assign 13's to everything in the slice
  gsl = valarray&lt;int&gt;(buf13,9);

  // print out the slice and our original valarray
  cout &lt;&lt; gsl &lt;&lt; endl &lt;&lt; vi &lt;&lt;  endl;

  return 0;
}</PRE>

</UL>
<P><B>Program Output</B></P>
<UL>
<PRE>
[0,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,2,3,4,5,6,7,8,9,10]
[0,2,4,3,5,7,6,8,10]
[13,13,13,13,13,13,13,13,13]
[13,1,2,13,4,5,13,7,8,1,13,3,4,13,6,7,13,9,2,3,13,5,6,13,8,9,13]</PRE>

</UL>

<A NAME="Warnings"><H3>Warnings</H3></A>
<P>If your compiler does not support namespaces, then you do not need the using declaration for <SAMP>std</SAMP>.</P>

<A NAME="See Also"><H3>See Also</H3></A>
<P><B><I><A HREF="val_6244.htm">valarray</A></I></B>, <B><I><A HREF="sli_1044.htm">slice_array</A></I></B>, <B><I><A HREF="sli_0626.htm">slice</A></I></B>, <B><I><A HREF="gsl_4121.htm">gslice</A></I></B>, <B><I><A HREF="mas_2579.htm">mask_array</A></I></B>, <B><I><A HREF="ind_9304.htm">indirect_array</A></I></B></P>


<BR>
<HR>
<A HREF="gsl_4121.htm"><IMG SRC="images/prev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=0></A><A HREF="index.htm"><IMG SRC="images/top.gif" WIDTH=56 HEIGHT=21 ALT="Top of document" BORDER=0></A><A HREF="classref.htm"><IMG SRC="images/toc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=0></A><A HREF="tindex.htm"><IMG SRC="images/index.gif" WIDTH=56 HEIGHT=21 ALT="Index" BORDER=0></A><A HREF="has_4618.htm"><IMG SRC="images/next.gif" WIDTH=19 HEIGHT=21 ALT="Next file" BORDER=0></A>
<BR>&copy;Copyright 1999, Rogue Wave Software, Inc.<BR>Send <A HREF="mailto:onlinedocs@roguewave.com">mail</A> to report errors or comment on the documentation.
<BR>
OEM Release</BODY></HTML>
